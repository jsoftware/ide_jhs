import{NodeProp}from"../../common/dist/index.js";import{LRParser,LocalTokenGroup}from"../../lr/dist/index.js";class Node{constructor(e){this.start=e}}class GrammarDeclaration extends Node{constructor(e,t,s,n,r,i,o,a,l,u,h,p,c,f,d){super(e),this.rules=t,this.topRules=s,this.tokens=n,this.localTokens=r,this.context=i,this.externalTokens=o,this.externalSpecializers=a,this.externalPropSources=l,this.precedences=u,this.mainSkip=h,this.scopedSkip=p,this.dialects=c,this.externalProps=f,this.autoDelim=d}toString(){return Object.values(this.rules).join("\n")}}class RuleDeclaration extends Node{constructor(e,t,s,n,r){super(e),this.id=t,this.props=s,this.params=n,this.expr=r}toString(){return this.id.name+(this.params.length?`<${this.params.join()}>`:"")+" -> "+this.expr}}class PrecDeclaration extends Node{constructor(e,t){super(e),this.items=t}}class TokenPrecDeclaration extends Node{constructor(e,t){super(e),this.items=t}}class TokenConflictDeclaration extends Node{constructor(e,t,s){super(e),this.a=t,this.b=s}}class TokenDeclaration extends Node{constructor(e,t,s,n,r){super(e),this.precedences=t,this.conflicts=s,this.rules=n,this.literals=r}}class LocalTokenDeclaration extends Node{constructor(e,t,s,n){super(e),this.precedences=t,this.rules=s,this.fallback=n}}class LiteralDeclaration extends Node{constructor(e,t,s){super(e),this.literal=t,this.props=s}}class ContextDeclaration extends Node{constructor(e,t,s){super(e),this.id=t,this.source=s}}class ExternalTokenDeclaration extends Node{constructor(e,t,s,n){super(e),this.id=t,this.source=s,this.tokens=n}}class ExternalSpecializeDeclaration extends Node{constructor(e,t,s,n,r,i){super(e),this.type=t,this.token=s,this.id=n,this.source=r,this.tokens=i}}class ExternalPropSourceDeclaration extends Node{constructor(e,t,s){super(e),this.id=t,this.source=s}}class ExternalPropDeclaration extends Node{constructor(e,t,s,n){super(e),this.id=t,this.externalID=s,this.source=n}}class Identifier extends Node{constructor(e,t){super(e),this.name=t}toString(){return this.name}}class Expression extends Node{walk(e){return e(this)}eq(e){return!1}}Expression.prototype.prec=10;class NameExpression extends Expression{constructor(e,t,s){super(e),this.id=t,this.args=s}toString(){return this.id.name+(this.args.length?`<${this.args.join()}>`:"")}eq(e){return this.id.name==e.id.name&&exprsEq(this.args,e.args)}walk(e){let t=walkExprs(this.args,e);return e(t==this.args?this:new NameExpression(this.start,this.id,t))}}class SpecializeExpression extends Expression{constructor(e,t,s,n,r){super(e),this.type=t,this.props=s,this.token=n,this.content=r}toString(){return`@${this.type}[${this.props.join(",")}]<${this.token}, ${this.content}>`}eq(e){return this.type==e.type&&Prop.eqProps(this.props,e.props)&&exprEq(this.token,e.token)&&exprEq(this.content,e.content)}walk(e){let t=this.token.walk(e),s=this.content.walk(e);return e(t==this.token&&s==this.content?this:new SpecializeExpression(this.start,this.type,this.props,t,s))}}class InlineRuleExpression extends Expression{constructor(e,t){super(e),this.rule=t}toString(){let e=this.rule;return`${e.id}${e.props.length?`[${e.props.join(",")}]`:""} { ${e.expr} }`}eq(e){let t=this.rule,s=e.rule;return exprEq(t.expr,s.expr)&&t.id.name==s.id.name&&Prop.eqProps(t.props,s.props)}walk(e){let t=this.rule,s=t.expr.walk(e);return e(s==t.expr?this:new InlineRuleExpression(this.start,new RuleDeclaration(t.start,t.id,t.props,[],s)))}}class ChoiceExpression extends Expression{constructor(e,t){super(e),this.exprs=t}toString(){return this.exprs.map((e=>maybeParens(e,this))).join(" | ")}eq(e){return exprsEq(this.exprs,e.exprs)}walk(e){let t=walkExprs(this.exprs,e);return e(t==this.exprs?this:new ChoiceExpression(this.start,t))}}ChoiceExpression.prototype.prec=1;class SequenceExpression extends Expression{constructor(e,t,s,n=!1){super(e),this.exprs=t,this.markers=s,this.empty=n}toString(){return this.empty?"()":this.exprs.map((e=>maybeParens(e,this))).join(" ")}eq(e){return exprsEq(this.exprs,e.exprs)&&this.markers.every(((t,s)=>{let n=e.markers[s];return t.length==n.length&&t.every(((e,t)=>e.eq(n[t])))}))}walk(e){let t=walkExprs(this.exprs,e);return e(t==this.exprs?this:new SequenceExpression(this.start,t,this.markers,this.empty&&!t.length))}}SequenceExpression.prototype.prec=2;class ConflictMarker extends Node{constructor(e,t,s){super(e),this.id=t,this.type=s}toString(){return("ambig"==this.type?"~":"!")+this.id.name}eq(e){return this.id.name==e.id.name&&this.type==e.type}}class RepeatExpression extends Expression{constructor(e,t,s){super(e),this.expr=t,this.kind=s}toString(){return maybeParens(this.expr,this)+this.kind}eq(e){return exprEq(this.expr,e.expr)&&this.kind==e.kind}walk(e){let t=this.expr.walk(e);return e(t==this.expr?this:new RepeatExpression(this.start,t,this.kind))}}RepeatExpression.prototype.prec=3;class LiteralExpression extends Expression{constructor(e,t){super(e),this.value=t}toString(){return JSON.stringify(this.value)}eq(e){return this.value==e.value}}class SetExpression extends Expression{constructor(e,t,s){super(e),this.ranges=t,this.inverted=s}toString(){return`[${this.inverted?"^":""}${this.ranges.map((([e,t])=>String.fromCodePoint(e)+(t==e+1?"":"-"+String.fromCodePoint(t))))}]`}eq(e){return this.inverted==e.inverted&&this.ranges.length==e.ranges.length&&this.ranges.every((([t,s],n)=>{let[r,i]=e.ranges[n];return t==r&&s==i}))}}class AnyExpression extends Expression{constructor(e){super(e)}toString(){return"_"}eq(){return!0}}function walkExprs(e,t){let s=null;for(let n=0;n<e.length;n++){let r=e[n].walk(t);r==e[n]||s||(s=e.slice(0,n)),s&&s.push(r)}return s||e}const CharClasses={asciiLetter:[[65,91],[97,123]],asciiLowercase:[[97,123]],asciiUppercase:[[65,91]],digit:[[48,58]],whitespace:[[9,14],[32,33],[133,134],[160,161],[5760,5761],[8192,8203],[8232,8234],[8239,8240],[8287,8288],[12288,12289]],eof:[[65535,65535]]};class CharClass extends Expression{constructor(e,t){super(e),this.type=t}toString(){return"@"+this.type}eq(e){return this.type==e.type}}function exprEq(e,t){return e.constructor==t.constructor&&e.eq(t)}function exprsEq(e,t){return e.length==t.length&&e.every(((e,s)=>exprEq(e,t[s])))}class Prop extends Node{constructor(e,t,s,n){super(e),this.at=t,this.name=s,this.value=n}eq(e){return this.name==e.name&&this.value.length==e.value.length&&this.value.every(((t,s)=>t.value==e.value[s].value&&t.name==e.value[s].name))}toString(){let e=(this.at?"@":"")+this.name;if(this.value.length){e+="=";for(let{name:t,value:s}of this.value)e+=t?`{${t}}`:/[^\w-]/.test(s)?JSON.stringify(s):s}return e}static eqProps(e,t){return e.length==t.length&&e.every(((e,s)=>e.eq(t[s])))}}class PropPart extends Node{constructor(e,t,s){super(e),this.value=t,this.name=s}}function maybeParens(e,t){return e.prec<t.prec?"("+e.toString()+")":e.toString()}class GenError extends Error{}function hasProps(e){for(let t in e)return!0;return!1}let termHash=0;class Term{constructor(e,t,s,n={}){this.name=e,this.flags=t,this.nodeName=s,this.props=n,this.hash=++termHash,this.id=-1,this.rules=[]}toString(){return this.name}get nodeType(){return this.top||null!=this.nodeName||hasProps(this.props)||this.repeated}get terminal(){return(1&this.flags)>0}get eof(){return(4&this.flags)>0}get error(){return"error"in this.props}get top(){return(2&this.flags)>0}get interesting(){return this.flags>0||null!=this.nodeName}get repeated(){return(16&this.flags)>0}set preserve(e){this.flags=e?8|this.flags:-9&this.flags}get preserve(){return(8&this.flags)>0}set inline(e){this.flags=e?32|this.flags:-33&this.flags}get inline(){return(32&this.flags)>0}cmp(e){return this.hash-e.hash}}class TermSet{constructor(){this.terms=[],this.names=Object.create(null),this.tops=[],this.eof=this.term("␄",null,5),this.error=this.term("⚠","⚠",8)}term(e,t,s=0,n={}){let r=new Term(e,s,t,n);return this.terms.push(r),this.names[e]=r,r}makeTop(e,t){const s=this.term("@top",e,2,t);return this.tops.push(s),s}makeTerminal(e,t,s={}){return this.term(e,t,1,s)}makeNonTerminal(e,t,s={}){return this.term(e,t,0,s)}makeRepeat(e){return this.term(e,null,16)}uniqueName(e){for(let t=0;;t++){let s=t?`${e}-${t}`:e;if(!this.names[s])return s}}finish(e){for(let t of e)t.name.rules.push(t);this.terms=this.terms.filter((t=>t.terminal||t.preserve||e.some((e=>e.name==t||e.parts.includes(t)))));let t={},s=[this.error];this.error.id=0;let n=1;for(let e of this.terms)e.id<0&&e.nodeType&&!e.repeated&&(e.id=n++,s.push(e));let r=n;for(let e of this.terms)e.repeated&&(e.id=n++,s.push(e));this.eof.id=n++;for(let e of this.terms)e.id<0&&(e.id=n++),e.name&&(t[e.id]=e.name);if(n>=65534)throw new GenError("Too many terms");return{nodeTypes:s,names:t,minRepeatTerm:r,maxTerm:n-1}}}function cmpSet(e,t,s){if(e.length!=t.length)return e.length-t.length;for(let n=0;n<e.length;n++){let r=s(e[n],t[n]);if(r)return r}return 0}const none$3=[];class Conflicts{constructor(e,t=none$3,s=0){this.precedence=e,this.ambigGroups=t,this.cut=s}join(e){return this==Conflicts.none||this==e?e:e==Conflicts.none?this:new Conflicts(Math.max(this.precedence,e.precedence),union(this.ambigGroups,e.ambigGroups),Math.max(this.cut,e.cut))}cmp(e){return this.precedence-e.precedence||cmpSet(this.ambigGroups,e.ambigGroups,((e,t)=>e<t?-1:e>t?1:0))||this.cut-e.cut}}function union(e,t){if(0==e.length||e==t)return t;if(0==t.length)return e;let s=e.slice();for(let n of t)e.includes(n)||s.push(n);return s.sort()}Conflicts.none=new Conflicts(0);let ruleID=0;class Rule{constructor(e,t,s,n){this.name=e,this.parts=t,this.conflicts=s,this.skip=n,this.id=ruleID++}cmp(e){return this.id-e.id}cmpNoName(e){return this.parts.length-e.parts.length||this.skip.hash-e.skip.hash||this.parts.reduce(((t,s,n)=>t||s.cmp(e.parts[n])),0)||cmpSet(this.conflicts,e.conflicts,((e,t)=>e.cmp(t)))}toString(){return this.name+" -> "+this.parts.join(" ")}get isRepeatWrap(){return this.name.repeated&&2==this.parts.length&&this.parts[0]==this.name}sameReduce(e){return this.name==e.name&&this.parts.length==e.parts.length&&this.isRepeatWrap==e.isRepeatWrap}}const MAX_CHAR=65535;class Edge{constructor(e,t,s){this.from=e,this.to=t,this.target=s}toString(){return`-> ${this.target.id}[label=${JSON.stringify(this.from<0?"ε":charFor(this.from)+(this.to>this.from+1?"-"+charFor(this.to-1):""))}]`}}function charFor(e){return e>65535?"∞":10==e?"\\n":13==e?"\\r":e<32||e>=55296&&e<57343?"\\u{"+e.toString(16)+"}":String.fromCharCode(e)}function minimize(e,t){let s=Object.create(null),n=Object.create(null);for(let t of e){let e=ids(t.accepting),r=n[e]||(n[e]=[]);r.push(t),s[t.id]=r}for(;;){let n=!1,r=Object.create(null);for(let t of e){if(r[t.id])continue;let e=s[t.id];if(1==e.length){r[e[0].id]=e;continue}let i=[];e:for(let t of e){for(let e of i)if(isEquivalent(t,e[0],s)){e.push(t);continue e}i.push([t])}i.length>1&&(n=!0);for(let e of i)for(let t of e)r[t.id]=e}if(!n)return applyMinimization(e,t,s);s=r}}function isEquivalent(e,t,s){if(e.edges.length!=t.edges.length)return!1;for(let n=0;n<e.edges.length;n++){let r=e.edges[n],i=t.edges[n];if(r.from!=i.from||r.to!=i.to||s[r.target.id]!=s[i.target.id])return!1}return!0}function applyMinimization(e,t,s){for(let t of e)for(let e=0;e<t.edges.length;e++){let n=t.edges[e],r=s[n.target.id][0];r!=n.target&&(t.edges[e]=new Edge(n.from,n.to,r))}return s[t.id][0]}let stateID=1,State$1=class e{constructor(e=[],t=stateID++){this.accepting=e,this.id=t,this.edges=[]}edge(e,t,s){this.edges.push(new Edge(e,t,s))}nullEdge(e){this.edge(-1,-1,e)}compile(){let t=Object.create(null),s=0,n=function n(r){let i=t[ids(r)]=new e(r.reduce(((e,t)=>union(e,t.accepting)),[]),s++),o=[];for(let e of r)for(let t of e.edges)t.from>=0&&o.push(t);let a=mergeEdges(o);for(let e of a){let s=e.targets.sort(((e,t)=>e.id-t.id));i.edge(e.from,e.to,t[ids(s)]||n(s))}return i}(this.closure().sort(((e,t)=>e.id-t.id)));return minimize(Object.values(t),n)}closure(){let e=[],t=Object.create(null);return function s(n){if(!t[n.id]){t[n.id]=!0,(n.edges.some((e=>e.from>=0))||n.accepting.length>0&&!n.edges.some((e=>sameSet$1(n.accepting,e.target.accepting))))&&e.push(n);for(let e of n.edges)e.from<0&&s(e.target)}}(this),e}findConflicts(e){let t=[],s=this.cycleTerms();function n(e,s,n,r,i){e.id<s.id&&([e,s]=[s,e],n=-n);let o=t.find((t=>t.a==e&&t.b==s));o?o.soft!=n&&(o.soft=0):t.push(new Conflict$1(e,s,n,exampleFromEdges(r),i&&exampleFromEdges(i)))}return this.reachable(((t,r)=>{if(0!=t.accepting.length){for(let e=0;e<t.accepting.length;e++)for(let s=e+1;s<t.accepting.length;s++)n(t.accepting[e],t.accepting[s],0,r);t.reachable(((i,o)=>{if(i!=t)for(let a of i.accepting){let i=s.includes(a);for(let l of t.accepting)a!=l&&n(a,l,i||s.includes(l)||!e(a,l)?0:1,r,r.concat(o))}}))}})),t}cycleTerms(){let e=[];this.reachable((t=>{for(let{target:s}of t.edges)e.push(t,s)}));let t=new Map,s=[];for(let n=0;n<e.length;){let r=e[n++],i=e[n++],o=t.get(r);if(o||t.set(r,o=[]),!o.includes(i))if(r==i)s.includes(r)||s.push(r);else{for(let t of o)e.push(r,t);o.push(i)}}let n=[];for(let e of s)for(let t of e.accepting)n.includes(t)||n.push(t);return n}reachable(e){let t=[],s=[];!function n(r){e(r,s),t.push(r);for(let e of r.edges)t.includes(e.target)||(s.push(e),n(e.target),s.pop())}(this)}toString(){let e="digraph {\n";return this.reachable((t=>{t.accepting.length&&(e+=`  ${t.id} [label=${JSON.stringify(t.accepting.join())}];\n`);for(let s of t.edges)e+=`  ${t.id} ${s};\n`})),e+"}"}toArray(e,t){let s=[],n=[];this.reachable((r=>{let i=n.length,o=i+3+2*r.accepting.length;s[r.id]=i,n.push(r.stateMask(e),o,r.edges.length),r.accepting.sort(((e,s)=>t.indexOf(e.id)-t.indexOf(s.id)));for(let t of r.accepting)n.push(t.id,e[t.id]||65535);for(let e of r.edges)n.push(e.from,e.to,-e.target.id-1)}));for(let e=0;e<n.length;e++)n[e]<0&&(n[e]=s[-n[e]-1]);if(n.length>Math.pow(2,16))throw new GenError("Tokenizer tables too big to represent with 16-bit offsets.");return Uint16Array.from(n)}stateMask(e){let t=0;return this.reachable((s=>{for(let n of s.accepting)t|=e[n.id]||65535})),t}},Conflict$1=class{constructor(e,t,s,n,r){this.a=e,this.b=t,this.soft=s,this.exampleA=n,this.exampleB=r}};function exampleFromEdges(e){let t="";for(let s=0;s<e.length;s++)t+=String.fromCharCode(e[s].from);return t}function ids(e){let t="";for(let s of e)t.length&&(t+="-"),t+=s.id;return t}function sameSet$1(e,t){if(e.length!=t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!=t[s])return!1;return!0}class MergedEdge{constructor(e,t,s){this.from=e,this.to=t,this.targets=s}}function mergeEdges(e){let t=[],s=[];for(let s of e)t.includes(s.from)||t.push(s.from),t.includes(s.to)||t.push(s.to);t.sort(((e,t)=>e-t));for(let n=1;n<t.length;n++){let r=t[n-1],i=t[n],o=[];for(let t of e)if(t.to>r&&t.from<i)for(let e of t.target.closure())o.includes(e)||o.push(e);o.length&&s.push(new MergedEdge(r,i,o))}let n=e.filter((e=>65535==e.from&&65535==e.to));if(n.length){let e=[];for(let t of n)for(let s of t.target.closure())e.includes(s)||e.push(s);e.length&&s.push(new MergedEdge(65535,65535,e))}return s}let word=/[\w_-]+/gy;try{word=/[\p{Alphabetic}\d_-]+/guy}catch(e){}const none$2=[];class Input{constructor(e,t=null){this.string=e,this.fileName=t,this.type="sof",this.value=null,this.start=0,this.end=0,this.next()}lineInfo(e){for(let t=1,s=0;;){let n=this.string.indexOf("\n",s);if(!(n>-1&&n<e))return{line:t,ch:e-s};++t,s=n+1}}message(e,t=-1){let s=this.fileName||"";if(t>-1){let e=this.lineInfo(t);s+=(s?" ":"")+e.line+":"+e.ch}return s?e+` (${s})`:e}raise(e,t=-1){throw new GenError(this.message(e,t))}match(e,t){let s=t.exec(this.string.slice(e));return s?e+s[0].length:-1}next(){let e=this.match(this.end,/^(\s|\/\/.*|\/\*[^]*?\*\/)*/);if(e==this.string.length)return this.set("eof",null,e,e);let t=this.string[e];if('"'==t){let t=this.match(e+1,/^(\\.|[^"\\])*"/);return-1==t&&this.raise("Unterminated string literal",e),this.set("string",readString(this.string.slice(e+1,t-1)),e,t)}if("'"==t){let t=this.match(e+1,/^(\\.|[^'\\])*'/);return-1==t&&this.raise("Unterminated string literal",e),this.set("string",readString(this.string.slice(e+1,t-1)),e,t)}if("@"==t){word.lastIndex=e+1;let t=word.exec(this.string);return t?this.set("at",t[0],e,e+1+t[0].length):this.raise("@ without a name",e)}if("$"!=t&&"!"!=t||"["!=this.string[e+1]){if(/[\[\]()!~+*?{}<>\.,|:$=]/.test(t))return this.set(t,null,e,e+1);{word.lastIndex=e;let s=word.exec(this.string);return s?this.set("id",s[0],e,e+s[0].length):this.raise("Unexpected character "+JSON.stringify(t),e)}}{let t=this.match(e+2,/^(?:\\.|[^\]\\])*\]/);return-1==t&&this.raise("Unterminated character set",e),this.set("set",this.string.slice(e+2,t-1),e,t)}}set(e,t,s,n){this.type=e,this.value=t,this.start=s,this.end=n}eat(e,t=null){return this.type==e&&(null==t||this.value===t)&&(this.next(),!0)}unexpected(){return this.raise(`Unexpected token '${this.string.slice(this.start,this.end)}'`,this.start)}expect(e,t=null){let s=this.value;return(this.type!=e||null!=t&&s!==t)&&this.unexpected(),this.next(),s}parse(){return parseGrammar(this)}}function parseGrammar(e){let t=e.start,s=[],n=null,r=null,i=[],o=null,a=[],l=[],u=null,h=[],p=[],c=[],f=[],d=[],m=!1,g=!1;for(;"eof"!=e.type;){let t=e.start;if(e.eat("at","top"))"id"!=e.type&&e.raise("Top rules must have a name",e.start),d.push(parseRule(e,parseIdent(e))),m=!0;else if("at"==e.type&&"tokens"==e.value)r?e.raise("Multiple @tokens declaractions",e.start):r=parseTokens(e);else if(e.eat("at","local"))e.expect("id","tokens"),i.push(parseLocalTokens(e,t));else if(e.eat("at","context")){u&&e.raise("Multiple @context declarations",t);let s=parseIdent(e);e.expect("id","from");let n=e.expect("string");u=new ContextDeclaration(t,s,n)}else if(e.eat("at","external"))e.eat("id","tokens")?h.push(parseExternalTokens(e,t)):e.eat("id","prop")?c.push(parseExternalProp(e,t)):e.eat("id","extend")?p.push(parseExternalSpecialize(e,"extend",t)):e.eat("id","specialize")?p.push(parseExternalSpecialize(e,"specialize",t)):e.eat("id","propSource")?f.push(parseExternalPropSource(e,t)):e.unexpected();else if(e.eat("at","dialects")){e.expect("{");for(let t=!0;!e.eat("}");t=!1)t||e.eat(","),l.push(parseIdent(e))}else if("at"==e.type&&"precedence"==e.value)n&&e.raise("Multiple precedence declarations",e.start),n=parsePrecedence(e);else if(e.eat("at","detectDelim"))g=!0;else if(e.eat("at","skip")){let t=parseBracedExpr(e);if("{"==e.type){e.next();let s=[],n=[];for(;!e.eat("}");)e.eat("at","top")?(n.push(parseRule(e,parseIdent(e))),m=!0):s.push(parseRule(e));a.push({expr:t,topRules:n,rules:s})}else o&&e.raise("Multiple top-level skip declarations",e.start),o=t}else s.push(parseRule(e))}return m?new GrammarDeclaration(t,s,d,r,i,u,h,p,f,n,o,a,l,c,g):e.raise("Missing @top declaration")}function parseRule(e,t){let s=t?t.start:e.start,n=t||parseIdent(e),r=parseProps(e),i=[];if(e.eat("<"))for(;!e.eat(">");)i.length&&e.expect(","),i.push(parseIdent(e));let o=parseBracedExpr(e);return new RuleDeclaration(s,n,r,i,o)}function parseProps(e){if("["!=e.type)return none$2;let t=[];for(e.expect("[");!e.eat("]");)t.length&&e.expect(","),t.push(parseProp(e));return t}function parseProp(e){let t=e.start,s=[],n=e.value,r="at"==e.type;if(e.eat("at")||e.eat("id")||e.unexpected(),e.eat("="))for(;;)if("string"==e.type||"id"==e.type)s.push(new PropPart(e.start,e.value,null)),e.next();else if(e.eat("."))s.push(new PropPart(e.start,".",null));else{if(!e.eat("{"))break;s.push(new PropPart(e.start,null,e.expect("id"))),e.expect("}")}return new Prop(t,r,n,s)}function parseBracedExpr(e){e.expect("{");let t=parseExprChoice(e);return e.expect("}"),t}const SET_MARKER="﷚";function parseExprInner(e){let t=e.start;if(e.eat("(")){if(e.eat(")"))return new SequenceExpression(t,none$2,[none$2,none$2]);let s=parseExprChoice(e);return e.expect(")"),s}if("string"==e.type){let s=e.value;return e.next(),0==s.length?new SequenceExpression(t,none$2,[none$2,none$2]):new LiteralExpression(t,s)}if(e.eat("id","_"))return new AnyExpression(t);if("set"==e.type){let s=e.value,n="!"==e.string[e.start],r=readString(s.replace(/\\.|-|"/g,(e=>"-"==e?SET_MARKER:'"'==e?'\\"':e))),i=[];for(let t=0;t<r.length;){let s=r.codePointAt(t);if(t+=s>65535?2:1,t<r.length-1&&r[t]==SET_MARKER){let n=r.codePointAt(t+1);t+=n>65535?3:2,n<s&&e.raise("Invalid character range",e.start),addRange(e,i,s,n+1)}else s==SET_MARKER.charCodeAt(0)&&(s=45),addRange(e,i,s,s+1)}return e.next(),new SetExpression(t,i.sort(((e,t)=>e[0]-t[0])),n)}if("at"!=e.type||"specialize"!=e.value&&"extend"!=e.value){if("at"==e.type&&CharClasses.hasOwnProperty(e.value)){let t=new CharClass(e.start,e.value);return e.next(),t}if("["==e.type){let s=parseRule(e,new Identifier(t,"_anon"));return s.params.length&&e.raise("Inline rules can't have parameters",s.start),new InlineRuleExpression(t,s)}{let s=parseIdent(e);if("["==e.type||"{"==e.type){let n=parseRule(e,s);return n.params.length&&e.raise("Inline rules can't have parameters",n.start),new InlineRuleExpression(t,n)}if(e.eat(".")&&"std"==s.name&&CharClasses.hasOwnProperty(e.value)){let s=new CharClass(t,e.value);return e.next(),s}return new NameExpression(t,s,parseArgs(e))}}{let{start:t,value:s}=e;e.next();let n=parseProps(e);e.expect("<");let r,i=parseExprChoice(e);return e.eat(",")?r=parseExprChoice(e):i instanceof LiteralExpression?r=i:e.raise(`@${s} requires two arguments when its first argument isn't a literal string`),e.expect(">"),new SpecializeExpression(t,s,n,i,r)}}function parseArgs(e){let t=[];if(e.eat("<"))for(;!e.eat(">");)t.length&&e.expect(","),t.push(parseExprChoice(e));return t}function addRange(e,t,s,n){t.every((([e,t])=>t<=s||e>=n))||e.raise("Overlapping character range",e.start),t.push([s,n])}function parseExprSuffix(e){let t=e.start,s=parseExprInner(e);for(;;){let n=e.type;if(!(e.eat("*")||e.eat("?")||e.eat("+")))return s;s=new RepeatExpression(t,s,n)}}function endOfSequence(e){return"}"==e.type||")"==e.type||"|"==e.type||"/"==e.type||"/\\"==e.type||"{"==e.type||","==e.type||">"==e.type}function parseExprSequence(e){let t=e.start,s=[],n=[none$2];do{for(;;){let t,s=e.start;if(e.eat("~"))t="ambig";else{if(!e.eat("!"))break;t="prec"}n[n.length-1]=n[n.length-1].concat(new ConflictMarker(s,parseIdent(e),t))}if(endOfSequence(e))break;s.push(parseExprSuffix(e)),n.push(none$2)}while(!endOfSequence(e));return 1==s.length&&n.every((e=>0==e.length))?s[0]:new SequenceExpression(t,s,n,!s.length)}function parseExprChoice(e){let t=e.start,s=parseExprSequence(e);if(!e.eat("|"))return s;let n=[s];do{n.push(parseExprSequence(e))}while(e.eat("|"));let r=n.find((e=>e instanceof SequenceExpression&&e.empty));return r&&e.raise("Empty expression in choice operator. If this is intentional, use () to make it explicit.",r.start),new ChoiceExpression(t,n)}function parseIdent(e){"id"!=e.type&&e.unexpected();let t=e.start,s=e.value;return e.next(),new Identifier(t,s)}function parsePrecedence(e){let t=e.start;e.next(),e.expect("{");let s=[];for(;!e.eat("}");)s.length&&e.eat(","),s.push({id:parseIdent(e),type:e.eat("at","left")?"left":e.eat("at","right")?"right":e.eat("at","cut")?"cut":null});return new PrecDeclaration(t,s)}function parseTokens(e){let t=e.start;e.next(),e.expect("{");let s=[],n=[],r=[],i=[];for(;!e.eat("}");)"at"==e.type&&"precedence"==e.value?r.push(parseTokenPrecedence(e)):"at"==e.type&&"conflict"==e.value?i.push(parseTokenConflict(e)):"string"==e.type?n.push(new LiteralDeclaration(e.start,e.expect("string"),parseProps(e))):s.push(parseRule(e));return new TokenDeclaration(t,r,i,s,n)}function parseLocalTokens(e,t){e.expect("{");let s=[],n=[],r=null;for(;!e.eat("}");)"at"==e.type&&"precedence"==e.value?n.push(parseTokenPrecedence(e)):e.eat("at","else")&&!r?r={id:parseIdent(e),props:parseProps(e)}:s.push(parseRule(e));return new LocalTokenDeclaration(t,n,s,r)}function parseTokenPrecedence(e){let t=e.start;e.next(),e.expect("{");let s=[];for(;!e.eat("}");){s.length&&e.eat(",");let t=parseExprInner(e);t instanceof LiteralExpression||t instanceof NameExpression?s.push(t):e.raise("Invalid expression in token precedences",t.start)}return new TokenPrecDeclaration(t,s)}function parseTokenConflict(e){let t=e.start;e.next(),e.expect("{");let s=parseExprInner(e);s instanceof LiteralExpression||s instanceof NameExpression||e.raise("Invalid expression in token conflict",s.start),e.eat(",");let n=parseExprInner(e);return n instanceof LiteralExpression||n instanceof NameExpression||e.raise("Invalid expression in token conflict",n.start),e.expect("}"),new TokenConflictDeclaration(t,s,n)}function parseExternalTokenSet(e){let t=[];for(e.expect("{");!e.eat("}");){t.length&&e.eat(",");let s=parseIdent(e),n=parseProps(e);t.push({id:s,props:n})}return t}function parseExternalTokens(e,t){let s=parseIdent(e);e.expect("id","from");let n=e.expect("string");return new ExternalTokenDeclaration(t,s,n,parseExternalTokenSet(e))}function parseExternalSpecialize(e,t,s){let n=parseBracedExpr(e),r=parseIdent(e);e.expect("id","from");let i=e.expect("string");return new ExternalSpecializeDeclaration(s,t,n,r,i,parseExternalTokenSet(e))}function parseExternalPropSource(e,t){let s=parseIdent(e);return e.expect("id","from"),new ExternalPropSourceDeclaration(t,s,e.expect("string"))}function parseExternalProp(e,t){let s=parseIdent(e),n=e.eat("id","as")?parseIdent(e):s;e.expect("id","from");let r=e.expect("string");return new ExternalPropDeclaration(t,n,s,r)}function readString(e){let t,s=/\\(?:u\{([\da-f]+)\}|u([\da-f]{4})|x([\da-f]{2})|([ntbrf0])|(.))|[^]/giy,n="";for(;t=s.exec(e);){let[e,s,r,i,o,a]=t;n+=s||r||i?String.fromCodePoint(parseInt(s||r||i,16)):o?"n"==o?"\n":"t"==o?"\t":"0"==o?"\0":"r"==o?"\r":"f"==o?"\f":"\b":a||e}return n}function hash(e,t){return(e<<5)+e+t}function hashString(e,t){for(let s=0;s<t.length;s++)e=hash(e,t.charCodeAt(s));return e}const verbose="undefined"!=typeof process&&process.env.LOG||"",timing=/\btime\b/.test(verbose),time=timing?(e,t)=>{let s=Date.now(),n=t();return console.log(`${e} (${((Date.now()-s)/1e3).toFixed(2)}s)`),n}:(e,t)=>t();class Pos{constructor(e,t,s,n,r,i){this.rule=e,this.pos=t,this.ahead=s,this.ambigAhead=n,this.skipAhead=r,this.via=i,this.hash=0}finish(){let e=hash(hash(this.rule.id,this.pos),this.skipAhead.hash);for(let t of this.ahead)e=hash(e,t.hash);for(let t of this.ambigAhead)e=hashString(e,t);return this.hash=e,this}get next(){return this.pos<this.rule.parts.length?this.rule.parts[this.pos]:null}advance(){return new Pos(this.rule,this.pos+1,this.ahead,this.ambigAhead,this.skipAhead,this.via).finish()}get skip(){return this.pos==this.rule.parts.length?this.skipAhead:this.rule.skip}cmp(e){return this.rule.cmp(e.rule)||this.pos-e.pos||this.skipAhead.hash-e.skipAhead.hash||cmpSet(this.ahead,e.ahead,((e,t)=>e.cmp(t)))||cmpSet(this.ambigAhead,e.ambigAhead,cmpStr)}eqSimple(e){return e.rule==this.rule&&e.pos==this.pos}toString(){let e=this.rule.parts.map((e=>e.name));return e.splice(this.pos,0,"·"),`${this.rule.name} -> ${e.join(" ")}`}eq(e){return this==e||this.hash==e.hash&&this.rule==e.rule&&this.pos==e.pos&&this.skipAhead==e.skipAhead&&sameSet(this.ahead,e.ahead)&&sameSet(this.ambigAhead,e.ambigAhead)}trail(e=60){let t=[];for(let e=this;e;e=e.via)for(let s=e.pos-1;s>=0;s--)t.push(e.rule.parts[s]);let s=t.reverse().join(" ");return s.length>e&&(s=s.slice(s.length-e).replace(/.*? /,"… ")),s}conflicts(e=this.pos){let t=this.rule.conflicts[e];return e==this.rule.parts.length&&this.ambigAhead.length&&(t=t.join(new Conflicts(0,this.ambigAhead))),t}static addOrigins(e,t){let s=e.slice();for(let e=0;e<s.length;e++){let n=s[e];if(0==n.pos)for(let e of t)e.next!=n.rule.name||s.includes(e)||s.push(e)}return s}}function conflictsAt(e){let t=Conflicts.none;for(let s of e)t=t.join(s.conflicts());return t}function compareRepeatPrec(e,t){for(let s of e)if(s.rule.name.repeated)for(let e of t)if(e.rule.name==s.rule.name){if(s.rule.isRepeatWrap&&2==s.pos)return 1;if(e.rule.isRepeatWrap&&2==e.pos)return-1}return 0}function cmpStr(e,t){return e<t?-1:e>t?1:0}function termsAhead(e,t,s,n){let r=[];for(let s=t+1;s<e.parts.length;s++){let t=e.parts[s],i=!1;if(t.terminal)addTo(t,r);else for(let e of n[t.name])null==e?i=!0:addTo(e,r);if(!i)return r}for(let e of s)addTo(e,r);return r}function eqSet(e,t){if(e.length!=t.length)return!1;for(let s=0;s<e.length;s++)if(!e[s].eq(t[s]))return!1;return!0}function sameSet(e,t){if(e.length!=t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!=t[s])return!1;return!0}class Shift{constructor(e,t){this.term=e,this.target=t}eq(e){return e instanceof Shift&&this.term==e.term&&e.target.id==this.target.id}cmp(e){return e instanceof Reduce?-1:this.term.id-e.term.id||this.target.id-e.target.id}matches(e,t){return e instanceof Shift&&t[e.target.id]==t[this.target.id]}toString(){return"s"+this.target.id}map(e,t){let s=t[e[this.target.id]];return s==this.target?this:new Shift(this.term,s)}}class Reduce{constructor(e,t){this.term=e,this.rule=t}eq(e){return e instanceof Reduce&&this.term==e.term&&e.rule.sameReduce(this.rule)}cmp(e){return e instanceof Shift?1:this.term.id-e.term.id||this.rule.name.id-e.rule.name.id||this.rule.parts.length-e.rule.parts.length}matches(e,t){return e instanceof Reduce&&e.rule.sameReduce(this.rule)}toString(){return`${this.rule.name.name}(${this.rule.parts.length})`}map(){return this}}function hashPositions(e){let t=5381;for(let s of e)t=hash(t,s.hash);return t}class ConflictContext{constructor(e){this.first=e,this.conflicts=[]}}class State{constructor(e,t,s=0,n,r=hashPositions(t),i=null){this.id=e,this.set=t,this.flags=s,this.skip=n,this.hash=r,this.startRule=i,this.actions=[],this.actionPositions=[],this.goto=[],this.tokenGroup=-1,this.defaultReduce=null,this._actionsByTerm=null}toString(){let e=this.actions.map((e=>e.term+"="+e)).join(",")+(this.goto.length?" | "+this.goto.map((e=>e.term+"="+e)).join(","):"");return this.id+": "+this.set.filter((e=>e.pos>0)).join()+(this.defaultReduce?`\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`:e.length?"\n  "+e:"")}addActionInner(e,t){e:for(let s=0;s<this.actions.length;s++){let n=this.actions[s];if(n.term==e.term){if(n.eq(e))return null;let r=Pos.addOrigins(t,this.set),i=Pos.addOrigins(this.actionPositions[s],this.set),o=conflictsAt(r),a=conflictsAt(i),l=compareRepeatPrec(r,i)||o.precedence-a.precedence;if(l>0){this.actions.splice(s,1),this.actionPositions.splice(s,1),s--;continue e}if(l<0)return null;if(o.ambigGroups.some((e=>a.ambigGroups.includes(e))))continue e;return n}}return this.actions.push(e),this.actionPositions.push(t),null}addAction(e,t,s){let n=this.addActionInner(e,t);if(n){let r,i=this.actionPositions[this.actions.indexOf(n)][0],o=[t[0].rule.name,i.rule.name];if(s.conflicts.some((e=>e.rules.some((e=>o.includes(e))))))return;r=n instanceof Shift?`shift/reduce conflict between\n  ${i}\nand\n  ${t[0].rule}`:`reduce/reduce conflict between\n  ${i.rule}\nand\n  ${t[0].rule}`,r+=`\nWith input:\n  ${t[0].trail(70)} · ${e.term} …`,n instanceof Shift&&(r+=findConflictShiftSource(t[0],n.term,s.first)),r+=findConflictOrigin(i,t[0]),s.conflicts.push(new Conflict(r,o))}}getGoto(e){return this.goto.find((t=>t.term==e))}hasSet(e){return eqSet(this.set,e)}actionsByTerm(){let e=this._actionsByTerm;if(!e){this._actionsByTerm=e=Object.create(null);for(let t of this.actions)(e[t.term.id]||(e[t.term.id]=[])).push(t)}return e}finish(){if(this.actions.length){let e=this.actions[0];if(e instanceof Reduce){let{rule:t}=e;this.actions.every((e=>e instanceof Reduce&&e.rule.sameReduce(t)))&&(this.defaultReduce=t)}}this.actions.sort(((e,t)=>e.cmp(t))),this.goto.sort(((e,t)=>e.cmp(t)))}eq(e){let t=this.defaultReduce,s=e.defaultReduce;return t||s?!(!t||!s)&&t.sameReduce(s):this.skip==e.skip&&this.tokenGroup==e.tokenGroup&&eqSet(this.actions,e.actions)&&eqSet(this.goto,e.goto)}}function closure(e,t){let s=[],n=[];function r(t,r,i,o,a){for(let l of t.rules){let t=s.find((e=>e.rule==l));if(!t){let n=e.find((e=>0==e.pos&&e.rule==l));t=n?new Pos(l,0,n.ahead.slice(),n.ambigAhead,n.skipAhead,n.via):new Pos(l,0,[],none$1,o,a),s.push(t)}if(t.skipAhead!=o)throw new GenError("Inconsistent skip sets after "+a.trail());t.ambigAhead=union(t.ambigAhead,i);for(let e of r)t.ahead.includes(e)||(t.ahead.push(e),t.rule.parts.length&&!t.rule.parts[0].terminal&&addTo(t,n))}}for(let s of e){let e=s.next;e&&!e.terminal&&r(e,termsAhead(s.rule,s.pos,s.ahead,t),s.conflicts(s.pos+1).ambigGroups,s.pos==s.rule.parts.length-1?s.skipAhead:s.rule.skip,s)}for(;n.length;){let e=n.pop();r(e.rule.parts[0],termsAhead(e.rule,0,e.ahead,t),union(e.rule.conflicts[1].ambigGroups,1==e.rule.parts.length?e.ambigAhead:none$1),1==e.rule.parts.length?e.skipAhead:e.rule.skip,e)}let i=e.slice();for(let t of s){t.ahead.sort(((e,t)=>e.hash-t.hash)),t.finish();let s=e.findIndex((e=>0==e.pos&&e.rule==t.rule));s>-1?i[s]=t:i.push(t)}return i.sort(((e,t)=>e.cmp(t)))}function addTo(e,t){t.includes(e)||t.push(e)}function computeFirstSets(e){let t=Object.create(null);for(let s of e.terms)s.terminal||(t[s.name]=[]);for(;;){let s=!1;for(let n of e.terms)if(!n.terminal)for(let e of n.rules){let r=t[n.name],i=!1,o=r.length;for(let s of e.parts){if(i=!0,s.terminal)addTo(s,r);else for(let e of t[s.name])null==e?i=!1:addTo(e,r);if(i)break}i||addTo(null,r),r.length>o&&(s=!0)}if(!s)return t}}class Core{constructor(e,t){this.set=e,this.state=t}}class Conflict{constructor(e,t){this.error=e,this.rules=t}}function findConflictOrigin(e,t){if(e.eqSimple(t))return"";function s(e,t){let s=[];for(let n=t.via;!n.eqSimple(e);n=n.via)s.push(n);return s.length?(s.unshift(t),s.reverse().map(((e,s)=>"\n"+"  ".repeat(s+1)+(e==t?"":"via ")+e)).join("")):""}for(let n=e;n;n=n.via)for(let r=t;r;r=r.via)if(n.eqSimple(r))return"\nShared origin: "+n+s(n,e)+s(n,t);return""}function findConflictShiftSource(e,t,s){let n=e,r=[];for(;;){for(let e=n.pos-1;e>=0;e--)r.push(n.rule.parts[e]);if(!n.via)break;n=n.via}r.reverse();let i=new Set;return function n(o,a,l){if(a==r.length&&l&&!o.next)return`\nThe reduction of ${e.rule.name} is allowed before ${t} because of this rule:\n  ${l}`;for(let e;e=o.next;){if(a<r.length&&e==r[a]){let e=n(o.advance(),a+1,l);if(e)return e}let u=o.rule.parts[o.pos+1],h=o.pos+1==o.rule.parts.length?l:null;u&&(u.terminal?u==t:s[u.name].includes(t))&&(h=o.advance());for(let t of e.rules){let s=(t.id<<5)+a+(h?555:0);if(!i.has(s)){i.add(s);let r=n(new Pos(t,0,[],[],e,o),a,h);if(r)return r}}if(e.terminal||!s[e.name].includes(null))break;o=o.advance()}return""}(n,0,null)}function buildFullAutomaton(e,t,s){let n=[],r={},i={},o=Date.now();function a(e,t){if(0==e.length)return null;let a,l=hashPositions(e),u=i[l];for(let t of e)if(a){if(a!=t.skip)throw new GenError("Inconsistent skip sets after "+t.trail())}else a=t.skip;if(u)for(let t of u)if(eqSet(e,t.set)){if(t.state.skip!=a)throw new GenError("Inconsistent skip sets after "+t.set[0].trail());return t.state}let h,p=closure(e,s),c=hashPositions(p),f=r[c]||(r[c]=[]);if(!t)for(let e of f)e.hasSet(p)&&(h=e);return h||(h=new State(n.length,p,0,a,c,t),f.push(h),n.push(h),timing&&n.length%500==0&&console.log(`${n.length} states after ${((Date.now()-o)/1e3).toFixed(2)}s`)),(i[l]||(i[l]=[])).push(new Core(e,h)),h}for(const s of t){const t=s.rules.length?s.rules[0].skip:e.names["%noskip"];a(s.rules.map((s=>new Pos(s,0,[e.eof],none$1,t,null).finish())),s)}let l=new ConflictContext(s);for(let e=0;e<n.length;e++){let t=n[e],r=[],i=[],o=[];for(let e of t.set)if(e.pos==e.rule.parts.length)e.rule.name.top||o.push(e);else{let t=e.rule.parts[e.pos],s=r.indexOf(t);s<0?(r.push(t),i.push([e])):i[s].push(e)}for(let e=0;e<r.length;e++){let s=r[e],n=i[e].map((e=>e.advance()));if(s.terminal){let r=a(applyCut(n));r&&t.addAction(new Shift(s,r),i[e],l)}else{let e=a(n);e&&t.goto.push(new Shift(s,e))}}let u=!1;for(let e of o)for(let s of e.ahead){let n=t.actions.length;t.addAction(new Reduce(s,e.rule),[e],l),t.actions.length==n&&(u=!0)}if(u)for(let e=0;e<t.goto.length;e++){s[t.goto[e].term.name].some((e=>t.actions.some((t=>t.term==e&&t instanceof Shift))))||t.goto.splice(e--,1)}}if(l.conflicts.length)throw new GenError(l.conflicts.map((e=>e.error)).join("\n\n"));for(let e of n)e.finish();return timing&&console.log(`${n.length} states total.`),n}function applyCut(e){let t=null,s=1;for(let n of e){let e=n.rule.conflicts[n.pos-1].cut;e<s||((!t||e>s)&&(s=e,t=[]),t.push(n))}return t||e}function canMerge(e,t,s){for(let n of e.goto)for(let e of t.goto)if(n.term==e.term&&s[n.target.id]!=s[e.target.id])return!1;let n=t.actionsByTerm();for(let t of e.actions){let r=n[t.term.id];if(r&&r.some((e=>!e.matches(t,s)))){if(1==r.length)return!1;let n=e.actionsByTerm()[t.term.id];if(n.length!=r.length||n.some((e=>!r.some((t=>e.matches(t,s))))))return!1}}return!0}function mergeStates(e,t){let s=[];for(let n of e){let e=t[n.id];s[e]||(s[e]=new State(e,n.set,0,n.skip,n.hash,n.startRule),s[e].tokenGroup=n.tokenGroup,s[e].defaultReduce=n.defaultReduce)}for(let n of e){let e=s[t[n.id]];e.flags|=n.flags;for(let r=0;r<n.actions.length;r++){let i=n.actions[r].map(t,s);e.actions.some((e=>e.eq(i)))||(e.actions.push(i),e.actionPositions.push(n.actionPositions[r]))}for(let r of n.goto){let n=r.map(t,s);e.goto.some((e=>e.eq(n)))||e.goto.push(n)}}return s}class Group{constructor(e,t){this.origin=e,this.members=[t]}}function samePosSet(e,t){if(e.length!=t.length)return!1;for(let s=0;s<e.length;s++)if(!e[s].eqSimple(t[s]))return!1;return!0}function collapseAutomaton(e){let t=[],s=[];e:for(let n=0;n<e.length;n++){let r=e[n];if(!r.startRule)for(let i=0;i<s.length;i++){let o=s[i],a=e[o.members[0]];if(r.tokenGroup==a.tokenGroup&&r.skip==a.skip&&!a.startRule&&samePosSet(r.set,a.set)){o.members.push(n),t.push(i);continue e}}t.push(s.length),s.push(new Group(s.length,n))}function n(n,r){let i=s[n],o=e[i.members[r]],a=i.members.pop();r!=i.members.length&&(i.members[r]=a);for(let r=n+1;r<s.length;r++)if(t[o.id]=r,s[r].origin==i.origin&&s[r].members.every((s=>canMerge(o,e[s],t))))return void s[r].members.push(o.id);t[o.id]=s.length,s.push(new Group(i.origin,o.id))}for(let r=1;;r++){let i=!1,o=Date.now();for(let r=0,o=s.length;r<o;r++){let o=s[r];for(let s=0;s<o.members.length-1;s++)for(let a=s+1;a<o.members.length;a++){let l=o.members[s],u=o.members[a];canMerge(e[l],e[u],t)||(i=!0,n(r,a--))}}if(timing&&console.log(`Collapse pass ${r}${i?"":", done"} (${((Date.now()-o)/1e3).toFixed(2)}s)`),!i)return mergeStates(e,t)}}function mergeIdentical(e){for(let t=1;;t++){let s=[],n=!1,r=Date.now(),i=[];for(let t=0;t<e.length;t++){let r=e[t],o=i.findIndex((e=>r.eq(e)));if(o<0)s[t]=i.length,i.push(r);else{s[t]=o,n=!0;let e=i[o],a=null;for(let t of r.set)e.set.some((e=>e.eqSimple(t)))||(a||(a=[])).push(t);a&&(e.set=a.concat(e.set).sort(((e,t)=>e.cmp(t))))}}if(timing&&console.log(`Merge identical pass ${t}${n?"":", done"} (${((Date.now()-r)/1e3).toFixed(2)}s)`),!n)return e;for(let e of i)e.defaultReduce||(e.actions=e.actions.map((e=>e.map(s,i))),e.goto=e.goto.map((e=>e.map(s,i))));for(let e=0;e<i.length;e++)i[e].id=e;e=i}}const none$1=[];function finishAutomaton(e){return mergeIdentical(collapseAutomaton(e))}function digitToChar(e){let t=e+32;return t>=34&&t++,t>=92&&t++,String.fromCharCode(t)}function encode(e,t=65535){if(e>t)throw new Error("Trying to encode a number that's too big: "+e);if(65535==e)return String.fromCharCode(126);let s="";for(let t=46;;t=0){let n=e%46,r=e-n;if(s=digitToChar(n+t)+s,0==r)break;e=r/46}return s}function encodeArray(e,t=65535){let s='"'+encode(e.length,4294967295);for(let n=0;n<e.length;n++)s+=encode(e[n],t);return s+='"',s}const none=[];class Parts{constructor(e,t){this.terms=e,this.conflicts=t}concat(e){if(this==Parts.none)return e;if(e==Parts.none)return this;let t=null;if(this.conflicts||e.conflicts){t=this.conflicts?this.conflicts.slice():this.ensureConflicts();let s=e.ensureConflicts();t[t.length-1]=t[t.length-1].join(s[0]);for(let e=1;e<s.length;e++)t.push(s[e])}return new Parts(this.terms.concat(e.terms),t)}withConflicts(e,t){if(t==Conflicts.none)return this;let s=this.conflicts?this.conflicts.slice():this.ensureConflicts();return s[e]=s[e].join(t),new Parts(this.terms,s)}ensureConflicts(){if(this.conflicts)return this.conflicts;let e=[];for(let t=0;t<=this.terms.length;t++)e.push(Conflicts.none);return e}}function p(...e){return new Parts(e,null)}Parts.none=new Parts(none,null);class BuiltRule{constructor(e,t,s){this.id=e,this.args=t,this.term=s}matches(e){return this.id==e.id.name&&exprsEq(e.args,this.args)}matchesRepeat(e){return"+"==this.id&&exprEq(e.expr,this.args[0])}}class Builder{constructor(e,t){this.options=t,this.terms=new TermSet,this.specialized=Object.create(null),this.tokenOrigins=Object.create(null),this.rules=[],this.built=[],this.ruleNames=Object.create(null),this.namespaces=Object.create(null),this.namedTerms=Object.create(null),this.termTable=Object.create(null),this.knownProps=Object.create(null),this.dynamicRulePrecedences=[],this.definedGroups=[],this.astRules=[],this.currentSkip=[],time("Parse",(()=>{this.input=new Input(e,t.fileName),this.ast=this.input.parse()}));let s=NodeProp;for(let e in s)s[e]instanceof NodeProp&&!s[e].perNode&&(this.knownProps[e]={prop:s[e],source:{name:e,from:null}});for(let e of this.ast.externalProps)this.knownProps[e.id.name]={prop:this.options.externalProp?this.options.externalProp(e.id.name):new NodeProp,source:{name:e.externalID.name,from:e.source}};this.dialects=this.ast.dialects.map((e=>e.name)),this.tokens=new MainTokenSet(this,this.ast.tokens),this.localTokens=this.ast.localTokens.map((e=>new LocalTokenSet(this,e))),this.externalTokens=this.ast.externalTokens.map((e=>new ExternalTokenSet(this,e))),this.externalSpecializers=this.ast.externalSpecializers.map((e=>new ExternalSpecializer(this,e))),time("Build rules",(()=>{let e=this.newName("%noskip",!0);this.defineRule(e,[]);let t=this.ast.mainSkip?this.newName("%mainskip",!0):e,s=[],n=[];for(let e of this.ast.rules)this.astRules.push({skip:t,rule:e});for(let e of this.ast.topRules)n.push({skip:t,rule:e});for(let r of this.ast.scopedSkip){let i=e,o=this.ast.scopedSkip.findIndex(((e,t)=>t<s.length&&exprEq(e.expr,r.expr)));o>-1?i=s[o]:this.ast.mainSkip&&exprEq(r.expr,this.ast.mainSkip)?i=t:isEmpty(r.expr)||(i=this.newName("%skip",!0)),s.push(i);for(let e of r.rules)this.astRules.push({skip:i,rule:e});for(let e of r.topRules)n.push({skip:i,rule:e})}for(let{rule:e}of this.astRules)this.unique(e.id);this.currentSkip.push(e),this.skipRules=t==e?[t]:[e,t],t!=e&&this.defineRule(t,this.normalizeExpr(this.ast.mainSkip));for(let t=0;t<this.ast.scopedSkip.length;t++){let n=s[t];this.skipRules.includes(n)||(this.skipRules.push(n),n!=e&&this.defineRule(n,this.normalizeExpr(this.ast.scopedSkip[t].expr)))}this.currentSkip.pop();for(let{rule:e,skip:t}of n.sort(((e,t)=>e.rule.start-t.rule.start))){this.unique(e.id),this.used(e.id.name),this.currentSkip.push(t);let{name:s,props:n}=this.nodeInfo(e.props,"a",e.id.name,none,none,e.expr),r=this.terms.makeTop(s,n);this.namedTerms[s]=r,this.defineRule(r,this.normalizeExpr(e.expr)),this.currentSkip.pop()}for(let e of this.externalSpecializers)e.finish();for(let{skip:e,rule:t}of this.astRules)this.ruleNames[t.id.name]&&isExported(t)&&!t.params.length&&(this.buildRule(t,[],e,!1),t.expr instanceof SequenceExpression&&0==t.expr.exprs.length&&this.used(t.id.name))}));for(let e in this.ruleNames){let t=this.ruleNames[e];t&&this.warn(`Unused rule '${t.name}'`,t.start)}this.tokens.takePrecedences(),this.tokens.takeConflicts();for(let e of this.localTokens)e.takePrecedences();for(let{name:e,group:t,rule:s}of this.definedGroups)this.defineGroup(e,t,s);this.checkGroups()}unique(e){e.name in this.ruleNames&&this.raise(`Duplicate definition of rule '${e.name}'`,e.start),this.ruleNames[e.name]=e}used(e){this.ruleNames[e]=null}newName(e,t=null,s={}){for(let n=t?0:1;;n++){let r=n?`${e}-${n}`:e;if(!this.terms.names[r])return this.terms.makeNonTerminal(r,!0===t?null:t,s)}}prepareParser(){let e=time("Simplify rules",(()=>simplifyRules(this.rules,[...this.skipRules,...this.terms.tops]))),{nodeTypes:t,names:s,minRepeatTerm:n,maxTerm:r}=this.terms.finish(e);for(let e in this.namedTerms)this.termTable[e]=this.namedTerms[e].id;/\bgrammar\b/.test(verbose)&&console.log(e.join("\n"));let i=this.terms.tops.slice(),o=computeFirstSets(this.terms),a=this.skipRules.map(((e,t)=>{let s=[],n=[],r=[];for(let t of e.rules){if(!t.parts.length)continue;let e=t.parts[0];for(let t of e.terminal?[e]:o[e.name]||[])t&&!n.includes(t)&&n.push(t);e.terminal&&1==t.parts.length&&!r.some((s=>s!=t&&s.parts[0]==e))?s.push(e):r.push(t)}return e.rules=r,r.length&&i.push(e),{skip:s,rule:r.length?e:null,startTokens:n,id:t}})),l=time("Build full automaton",(()=>buildFullAutomaton(this.terms,i,o))),u=this.localTokens.map(((e,t)=>e.buildLocalGroup(l,a,t))),{tokenGroups:h,tokenPrec:p,tokenData:c}=time("Build token groups",(()=>this.tokens.buildTokenGroups(l,a,u.length))),f=time("Finish automaton",(()=>finishAutomaton(l))),d=findSkipStates(f,this.terms.tops);/\blr\b/.test(verbose)&&console.log(f.join("\n"));let m=[];for(let e of this.externalSpecializers)m.push(e);for(let e in this.specialized)m.push({token:this.terms.names[e],table:buildSpecializeTable(this.specialized[e])});let g=e=>e instanceof ExternalTokenSet?e.ast.start:this.tokens.ast?this.tokens.ast.start:-1,x=h.concat(this.externalTokens).sort(((e,t)=>g(e)-g(t))).concat(u),k=new DataBuilder,b=a.map((e=>{let t=[];for(let s of e.skip)t.push(s.id,0,4);if(e.rule){let s=f.find((t=>t.startRule==e.rule));for(let e of s.actions)t.push(e.term.id,s.id,2)}return t.push(65535,0),k.storeArray(t)})),S=time("Finish states",(()=>{let e=new Uint32Array(6*f.length),t=this.computeForceReductions(f,a),s=new FinishStateContext(x,k,e,b,a,f,this);for(let e of f)s.finish(e,d(e.id),t[e.id]);return e})),y=Object.create(null);for(let e=0;e<this.dialects.length;e++)y[this.dialects[e]]=k.storeArray((this.tokens.byDialect[e]||none).map((e=>e.id)).concat(65535));let w=null;if(this.dynamicRulePrecedences.length){w=Object.create(null);for(let{rule:e,prec:t}of this.dynamicRulePrecedences)w[e.id]=t}let E=Object.create(null);for(let e of this.terms.tops)E[e.nodeName]=[f.find((t=>t.startRule==e)).id,e.id];let $=k.storeArray(p.concat(65535)),{nodeProps:T,skippedTypes:R}=this.gatherNodeProps(t);return{states:S,stateData:k.finish(),goto:computeGotoTable(f),nodeNames:t.filter((e=>e.id<n)).map((e=>e.nodeName)).join(" "),nodeProps:T,skippedTypes:R,maxTerm:r,repeatNodeCount:t.length-n,tokenizers:x,tokenData:c,topRules:E,dialects:y,dynamicPrecedences:w,specialized:m,tokenPrec:$,termNames:s}}getParser(){let{states:e,stateData:t,goto:s,nodeNames:n,nodeProps:r,skippedTypes:i,maxTerm:o,repeatNodeCount:a,tokenizers:l,tokenData:u,topRules:h,dialects:p,dynamicPrecedences:c,specialized:f,tokenPrec:d,termNames:m}=this.prepareParser(),g=f.map((e=>{if(e instanceof ExternalSpecializer){let t=this.options.externalSpecializer(e.ast.id.name,this.termTable);return{term:e.term.id,get:(s,n)=>t(s,n)<<1|("extend"==e.ast.type?1:0),external:t,extend:"extend"==e.ast.type}}return{term:e.token.id,get:t=>e.table[t]||-1}}));return LRParser.deserialize({version:14,states:e,stateData:t,goto:s,nodeNames:n,maxTerm:o,repeatNodeCount:a,nodeProps:r.map((({prop:e,terms:t})=>[this.knownProps[e].prop,...t])),propSources:this.options.externalPropSource?this.ast.externalPropSources.map((e=>this.options.externalPropSource(e.id.name))):void 0,skippedNodes:i,tokenData:u,tokenizers:l.map((e=>e.create())),context:this.ast.context?"function"==typeof this.options.contextTracker?this.options.contextTracker(this.termTable):this.options.contextTracker:void 0,topRules:h,dialects:p,dynamicPrecedences:c,specialized:g,tokenPrec:d,termNames:m})}getParserFile(){let{states:e,stateData:t,goto:s,nodeNames:n,nodeProps:r,skippedTypes:i,maxTerm:o,repeatNodeCount:a,tokenizers:l,tokenData:u,topRules:h,dialects:p,dynamicPrecedences:c,specialized:f,tokenPrec:d,termNames:m}=this.prepareParser(),g=this.options.moduleStyle||"es",x="// This file was generated by lezer-generator. You probably shouldn't edit it.\n",k=x,b={},S=Object.create(null),y=Object.create(null);for(let e of KEYWORDS)y[e]=!0;let w=this.options.exportName||"parser";y[w]=!0;let E=e=>{for(let t=0;;t++){let s=e+(t?"_"+t:"");if(!y[s])return s}},$=(e,t,s=e)=>{let n=e+" from "+t;if(S[n])return S[n];let r=JSON.stringify(t),i=e;return e in y&&(i=E(s),e+=`${"cjs"==g?":":" as"} ${i}`),y[i]=!0,(b[r]||(b[r]=[])).push(e),S[n]=i},T=$("LRParser","@lezer/lr"),R=l.map((e=>e.createSource($))),P=this.ast.context?$(this.ast.context.id.name,this.ast.context.source):null,v=r.map((({prop:e,terms:t})=>{let{source:s}=this.knownProps[e];return`[${s.from?$(s.name,s.from):JSON.stringify(s.name)}, ${t.map(O).join(",")}]`}));let A="",C=f.map((e=>{if(e instanceof ExternalSpecializer){let t=$(e.ast.id.name,e.ast.source),s=this.options.typeScript?": any":"";return`{term: ${e.term.id}, get: (value${s}, stack${s}) => (${t}(value, stack) << 1)${"extend"==e.ast.type?" | 1":""}, external: ${t}${"extend"==e.ast.type?", extend: true":""}}`}{let s=E("spec_"+e.token.name.replace(/\W/g,""));y[s]=!0,A+=`const ${s} = ${t=e.table,"{__proto__:null,"+Object.keys(t).map((e=>`${/^(\d+|[a-zA-Z_]\w*)$/.test(e)?e:JSON.stringify(e)}:${t[e]}`)).join(", ")+"}"}\n`;let n=this.options.typeScript?`: keyof typeof ${s}`:"";return`{term: ${e.token.id}, get: (value${n}) => ${s}[value] || -1}`}var t})),N=this.ast.externalPropSources.map((e=>$(e.id.name,e.source)));for(let e in b)k+="cjs"==g?`const {${b[e].join(", ")}} = require(${e})\n`:`import {${b[e].join(", ")}} from ${e}\n`;function O(e){return"string"!=typeof e||/^(true|false|\d+(\.\d+)?|\.\d+)$/.test(e)?e:JSON.stringify(e)}k+=A;let I=Object.keys(p).map((e=>`${e}: ${p[e]}`)),j=`${T}.deserialize({\n  version: 14,\n  states: ${encodeArray(e,4294967295)},\n  stateData: ${encodeArray(t)},\n  goto: ${encodeArray(s)},\n  nodeNames: ${JSON.stringify(n)},\n  maxTerm: ${o}${P?`,\n  context: ${P}`:""}${v.length?`,\n  nodeProps: [\n    ${v.join(",\n    ")}\n  ]`:""}${N.length?`,\n  propSources: [${N.join()}]`:""}${i.length?`,\n  skippedNodes: ${JSON.stringify(i)}`:""},\n  repeatNodeCount: ${a},\n  tokenData: ${encodeArray(u)},\n  tokenizers: [${R.join(", ")}],\n  topRules: ${JSON.stringify(h)}${I.length?`,\n  dialects: {${I.join(", ")}}`:""}${c?`,\n  dynamicPrecedences: ${JSON.stringify(c)}`:""}${C.length?`,\n  specialized: [${C.join(",")}]`:""},\n  tokenPrec: ${d}${this.options.includeNames?`,\n  termNames: ${JSON.stringify(m)}`:""}\n})`,D=[];for(let e in this.termTable){let t=e;if(KEYWORDS.includes(t))for(let s=1;t="_".repeat(s)+e,t in this.termTable;s++);else if(!/^[\w$]+$/.test(e))continue;D.push(`${t}${"cjs"==g?":":" ="} ${this.termTable[e]}`)}for(let e=0;e<this.dialects.length;e++)D.push(`Dialect_${this.dialects[e]}${"cjs"==g?":":" ="} ${e}`);return{parser:k+("cjs"==g?`exports.${w} = ${j}\n`:`export const ${w} = ${j}\n`),terms:"cjs"==g?`${x}module.exports = {\n  ${D.join(",\n  ")}\n}`:`${x}export const\n  ${D.join(",\n  ")}\n`}}gatherNonSkippedNodes(){let e=Object.create(null),t=[],s=s=>{e[s.id]||(e[s.id]=!0,t.push(s))};this.terms.tops.forEach(s);for(let e=0;e<t.length;e++)for(let n of t[e].rules)for(let e of n.parts)s(e);return e}gatherNodeProps(e){let t=this.gatherNonSkippedNodes(),s=[],n=[];for(let r of e){t[r.id]||r.error||s.push(r.id);for(let e in r.props){let t=this.knownProps[e];if(!t)throw new GenError("No known prop type for "+e);if(null==t.source.from&&("repeated"==t.source.name||"error"==t.source.name))continue;let s=n.find((t=>t.prop==e));s||n.push(s={prop:e,values:{}}),(s.values[r.props[e]]||(s.values[r.props[e]]=[])).push(r.id)}}return{nodeProps:n.map((({prop:e,values:t})=>{let s=[];for(let e in t){let n=t[e];if(1==n.length)s.push(n[0],e);else{s.push(-n.length);for(let e of n)s.push(e);s.push(e)}}return{prop:e,terms:s}})),skippedTypes:s}}makeTerminal(e,t,s){return this.terms.makeTerminal(this.terms.uniqueName(e),t,s)}computeForceReductions(e,t){let s=[],n=[],r=Object.create(null);for(let t of e){s.push(0);for(let e of t.goto){let s=r[e.term.id]||(r[e.term.id]=[]),n=s.find((t=>t.target==e.target.id));n?n.parents.push(t.id):s.push({parents:[t.id],target:e.target.id})}n[t.id]=t.set.filter((e=>e.pos>0&&!e.rule.name.top)).sort(((e,t)=>t.pos-e.pos||e.rule.parts.length-t.rule.parts.length))}let i=Object.create(null);function o(e,t,s=null){let n=r[e];return!!n&&n.some((e=>{let n=s?s.filter((t=>e.parents.includes(t))):e.parents;if(0==n.length)return!1;if(e.target==t)return!0;let r=i[e.target];return null!=r&&o(r,t,n)}))}for(let n of e)n.defaultReduce&&n.defaultReduce.parts.length>0&&(s[n.id]=reduceAction(n.defaultReduce,t),1==n.defaultReduce.parts.length&&(i[n.id]=n.defaultReduce.name.id));for(let r=1;;r++){let a=!0;for(let l of e){if(l.defaultReduce)continue;let e=n[l.id];if(e.length==r){for(let n of e)if(1!=n.pos||!o(n.rule.name.id,l.id)){s[l.id]=reduceAction(n.rule,t,n.pos),1==n.pos&&(i[l.id]=n.rule.name.id);break}}else e.length>r&&(a=!1)}if(a)break}return s}substituteArgs(e,t,s){return 0==t.length?e:e.walk((e=>{let n;if(e instanceof NameExpression&&(n=s.findIndex((t=>t.name==e.id.name)))>-1){let s=t[n];if(e.args.length){if(s instanceof NameExpression&&!s.args.length)return new NameExpression(e.start,s.id,e.args);this.raise("Passing arguments to a parameter that already has arguments",e.start)}return s}if(e instanceof InlineRuleExpression){let n=e.rule,r=this.substituteArgsInProps(n.props,t,s);return r==n.props?e:new InlineRuleExpression(e.start,new RuleDeclaration(n.start,n.id,r,n.params,n.expr))}if(e instanceof SpecializeExpression){let n=this.substituteArgsInProps(e.props,t,s);return n==e.props?e:new SpecializeExpression(e.start,e.type,n,e.token,e.content)}return e}))}substituteArgsInProps(e,t,s){let n=e=>{let n=e;for(let r=0;r<e.length;r++){let i=e[r];if(!i.name)continue;let o=s.findIndex((e=>e.name==i.name));if(o<0)continue;n==e&&(n=e.slice());let a=t[o];a instanceof NameExpression&&!a.args.length?n[r]=new PropPart(i.start,a.id.name,null):a instanceof LiteralExpression?n[r]=new PropPart(i.start,a.value,null):this.raise(`Trying to interpolate expression '${a}' into a prop`,i.start)}return n},r=e;for(let t=0;t<e.length;t++){let s=e[t],i=n(s.value);i!=s.value&&(r==e&&(r=e.slice()),r[t]=new Prop(s.start,s.at,s.name,i))}return r}conflictsFor(e){let t=Conflicts.none,s=Conflicts.none;for(let n of e)if("ambig"==n.type)t=t.join(new Conflicts(0,[n.id.name]));else{let e=this.ast.precedences,r=e?e.items.findIndex((e=>e.id.name==n.id.name)):-1;r<0&&this.raise(`Reference to unknown precedence: '${n.id.name}'`,n.id.start);let i=e.items[r],o=e.items.length-r;"cut"==i.type?t=t.join(new Conflicts(0,none,o)):(t=t.join(new Conflicts(o<<2)),s=s.join(new Conflicts((o<<2)+("left"==i.type?1:"right"==i.type?-1:0))))}return{here:t,atEnd:s}}raise(e,t=1){return this.input.raise(e,t)}warn(e,t=-1){let s=this.input.message(e,t);this.options.warn?this.options.warn(s):console.warn(s)}defineRule(e,t){let s=this.currentSkip[this.currentSkip.length-1];for(let n of t)this.rules.push(new Rule(e,n.terms,n.ensureConflicts(),s))}resolve(e){for(let t of this.built)if(t.matches(e))return[p(t.term)];let t=this.tokens.getToken(e);if(t)return[p(t)];for(let t of this.localTokens){let s=t.getToken(e);if(s)return[p(s)]}for(let t of this.externalTokens){let s=t.getToken(e);if(s)return[p(s)]}for(let t of this.externalSpecializers){let s=t.getToken(e);if(s)return[p(s)]}let s=this.astRules.find((t=>t.rule.id.name==e.id.name));return s?(s.rule.params.length!=e.args.length&&this.raise(`Wrong number or arguments for '${e.id.name}'`,e.start),this.used(s.rule.id.name),[p(this.buildRule(s.rule,e.args,s.skip))]):this.raise(`Reference to undefined rule '${e.id.name}'`,e.start)}normalizeRepeat(e){let t=this.built.find((t=>t.matchesRepeat(e)));if(t)return p(t.term);let s=e.expr.prec<e.prec?`(${e.expr})+`:`${e.expr}+`,n=this.terms.makeRepeat(this.terms.uniqueName(s));return this.built.push(new BuiltRule("+",[e.expr],n)),this.defineRule(n,this.normalizeExpr(e.expr).concat(p(n,n))),p(n)}normalizeSequence(e){let t=e.exprs.map((e=>this.normalizeExpr(e))),s=this;return function n(r,i,o){let{here:a,atEnd:l}=s.conflictsFor(e.markers[i]);if(i==t.length)return[r.withConflicts(r.terms.length,a.join(o))];let u=[];for(let e of t[i])for(let t of n(r.concat(e).withConflicts(r.terms.length,a),i+1,o.join(l)))u.push(t);return u}(Parts.none,0,Conflicts.none)}normalizeExpr(e){if(e instanceof RepeatExpression&&"?"==e.kind)return[Parts.none,...this.normalizeExpr(e.expr)];if(e instanceof RepeatExpression){let t=this.normalizeRepeat(e);return"+"==e.kind?[t]:[Parts.none,t]}return e instanceof ChoiceExpression?e.exprs.reduce(((e,t)=>e.concat(this.normalizeExpr(t))),[]):e instanceof SequenceExpression?this.normalizeSequence(e):e instanceof LiteralExpression?[p(this.tokens.getLiteral(e))]:e instanceof NameExpression?this.resolve(e):e instanceof SpecializeExpression?[p(this.resolveSpecialization(e))]:e instanceof InlineRuleExpression?[p(this.buildRule(e.rule,none,this.currentSkip[this.currentSkip.length-1],!0))]:this.raise(`This type of expression ('${e}') may not occur in non-token rules`,e.start)}buildRule(e,t,s,n=!1){let r=this.substituteArgs(e.expr,t,e.params),{name:i,props:o,dynamicPrec:a,inline:l,group:u,exported:h}=this.nodeInfo(e.props||none,n?"pg":"pgi",e.id.name,t,e.params,e.expr);h&&e.params.length&&this.warn("Can't export parameterized rules",e.start),h&&n&&this.warn("Can't export inline rule",e.start);let p=this.newName(e.id.name+(t.length?"<"+t.join(",")+">":""),i||!0,o);l&&(p.inline=!0),a&&this.registerDynamicPrec(p,a),(p.nodeType||h)&&0==e.params.length&&(i||(p.preserve=!0),n||(this.namedTerms[h||e.id.name]=p)),n||this.built.push(new BuiltRule(e.id.name,t,p)),this.currentSkip.push(s);let c=this.normalizeExpr(r);return c.length>100*(r instanceof ChoiceExpression?r.exprs.length:1)&&this.warn(`Rule ${e.id.name} is generating a lot (${c.length}) of choices.\n  Consider splitting it up or reducing the amount of ? or | operator uses.`,e.start),/\brulesize\b/.test(verbose)&&c.length>10&&console.log(`Rule ${e.id.name}: ${c.length} variants`),this.defineRule(p,c),this.currentSkip.pop(),u&&this.definedGroups.push({name:p,group:u,rule:e}),p}nodeInfo(e,t,s=null,n=none,r=none,i,o){let a={},l=s&&(t.indexOf("a")>-1||!ignored(s))&&!/ /.test(s)?s:null,u=null,h=0,p=!1,c=null,f=null;for(let i of e)if(i.at)if("name"==i.name)l=this.finishProp(i,n,r),/ /.test(l)&&this.raise(`Node names cannot have spaces ('${l}')`,i.start);else if("dialect"==i.name){t.indexOf("d")<0&&this.raise("Can't specify a dialect on non-token rules",e[0].start),1==i.value.length||i.value[0].value||this.raise("The '@dialect' rule prop must hold a plain string value");let s=this.dialects.indexOf(i.value[0].value);s<0&&this.raise(`Unknown dialect '${i.value[0].value}'`,i.value[0].start),u=s}else"dynamicPrecedence"==i.name?(t.indexOf("p")<0&&this.raise("Dynamic precedence can only be specified on nonterminals"),1==i.value.length&&/^-?(?:10|\d)$/.test(i.value[0].value)||this.raise("The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10"),h=+i.value[0].value):"inline"==i.name?(i.value.length&&this.raise("'@inline' doesn't take a value",i.value[0].start),t.indexOf("i")<0&&this.raise("Inline can only be specified on nonterminals"),p=!0):"isGroup"==i.name?(t.indexOf("g")<0&&this.raise("'@isGroup' can only be specified on nonterminals"),c=i.value.length?this.finishProp(i,n,r):s):"export"==i.name?f=i.value.length?this.finishProp(i,n,r):s:this.raise(`Unknown built-in prop name '@${i.name}'`,i.start);else{if(!this.knownProps[i.name]){let e=["name","dialect","dynamicPrecedence","export","isGroup"].includes(i.name)?` (did you mean '@${i.name}'?)`:"";this.raise(`Unknown prop name '${i.name}'${e}`,i.start)}a[i.name]=this.finishProp(i,n,r)}if(i&&this.ast.autoDelim&&(l||hasProps(a))){let e=this.findDelimiters(i);e&&(addToProp(e[0],"closedBy",e[1].nodeName),addToProp(e[1],"openedBy",e[0].nodeName))}if(o&&hasProps(o))for(let e in o)e in a||(a[e]=o[e]);return hasProps(a)&&!l&&this.raise("Node has properties but no name",e.length?e[0].start:i.start),p&&(hasProps(a)||u||h)&&this.raise("Inline nodes can't have props, dynamic precedence, or a dialect",e[0].start),p&&l&&(l=null),{name:l,props:a,dialect:u,dynamicPrec:h,inline:p,group:c,exported:f}}finishProp(e,t,s){return e.value.map((e=>{if(e.value)return e.value;let n=s.findIndex((t=>t.name==e.name));n<0&&this.raise(`Property refers to '${e.name}', but no parameter by that name is in scope`,e.start);let r=t[n];return r instanceof NameExpression&&!r.args.length?r.id.name:r instanceof LiteralExpression?r.value:this.raise(`Expression '${r}' can not be used as part of a property value`,e.start)})).join("")}resolveSpecialization(e){let t,s=e.type,{name:n,props:r,dialect:i,exported:o}=this.nodeInfo(e.props,"d"),a=this.normalizeExpr(e.token);if(1==a.length&&1==a[0].terms.length&&a[0].terms[0].terminal||this.raise(`The first argument to '${s}' must resolve to a token`,e.token.start),e.content instanceof LiteralExpression)t=[e.content.value];else{if(!(e.content instanceof ChoiceExpression&&e.content.exprs.every((e=>e instanceof LiteralExpression))))return this.raise(`The second argument to '${e.type}' must be a literal or choice of literals`,e.content.start);t=e.content.exprs.map((e=>e.value))}let l=a[0].terms[0],u=null,h=this.specialized[l.name]||(this.specialized[l.name]=[]);for(let a of t){let t=h.find((e=>e.value==a));null==t?(u||(u=this.makeTerminal(l.name+"/"+JSON.stringify(a),n,r),null!=i&&(this.tokens.byDialect[i]||(this.tokens.byDialect[i]=[])).push(u)),h.push({value:a,term:u,type:s,dialect:i,name:n}),this.tokenOrigins[u.name]={spec:l},(n||o)&&(n||(u.preserve=!0),this.namedTerms[o||n]=u)):(t.type!=s&&this.raise(`Conflicting specialization types for ${JSON.stringify(a)} of ${l.name} (${s} vs ${t.type})`,e.start),t.dialect!=i&&this.raise(`Conflicting dialects for specialization ${JSON.stringify(a)} of ${l.name}`,e.start),t.name!=n&&this.raise(`Conflicting names for specialization ${JSON.stringify(a)} of ${l.name}`,e.start),u&&t.term!=u&&this.raise(`Conflicting specialization tokens for ${JSON.stringify(a)} of ${l.name}`,e.start),u=t.term)}return u}findDelimiters(e){if(!(e instanceof SequenceExpression)||e.exprs.length<2)return null;let t=e=>{if(e instanceof LiteralExpression)return{term:this.tokens.getLiteral(e),str:e.value};if(e instanceof NameExpression&&0==e.args.length){let s=this.ast.rules.find((t=>t.id.name==e.id.name));if(s)return t(s.expr);let n=this.tokens.rules.find((t=>t.id.name==e.id.name));if(n&&n.expr instanceof LiteralExpression)return{term:this.tokens.getToken(e),str:n.expr.value}}return null},s=t(e.exprs[e.exprs.length-1]);if(!s||!s.term.nodeName)return null;let n=["()","[]","{}","<>"].find((e=>s.str.indexOf(e[1])>-1&&s.str.indexOf(e[0])<0));if(!n)return null;let r=t(e.exprs[0]);return!r||!r.term.nodeName||r.str.indexOf(n[0])<0||r.str.indexOf(n[1])>-1?null:[r.term,s.term]}registerDynamicPrec(e,t){this.dynamicRulePrecedences.push({rule:e,prec:t}),e.preserve=!0}defineGroup(e,t,s){var n;let r=[],i=e=>{if(e.nodeName)return[e];r.includes(e)&&this.raise(`Rule '${s.id.name}' cannot define a group because it contains a non-named recursive rule ('${e.name}')`,s.start);let t=[];r.push(e);for(let n of this.rules)if(n.name==e){let e=n.parts.map(i).filter((e=>e.length));if(e.length>1&&this.raise(`Rule '${s.id.name}' cannot define a group because some choices produce multiple named nodes`,s.start),1==e.length)for(let s of e[0])t.push(s)}return r.pop(),t};for(let s of i(e))s.props.group=((null===(n=s.props.group)||void 0===n?void 0:n.split(" "))||[]).concat(t).sort().join(" ")}checkGroups(){let e=Object.create(null),t=Object.create(null);for(let s of this.terms.terms)if(s.nodeName&&(t[s.nodeName]=!0,s.props.group))for(let t of s.props.group.split(" "))(e[t]||(e[t]=[])).push(s);let s=Object.keys(e);for(let n=0;n<s.length;n++){let r=s[n],i=e[r];t[r]&&this.warn(`Group name '${r}' conflicts with a node of the same name`);for(let t=n+1;t<s.length;t++){let n=e[s[t]];i.some((e=>n.includes(e)))&&(i.length>n.length?n.some((e=>!i.includes(e))):i.some((e=>!n.includes(e))))&&this.warn(`Groups '${r}' and '${s[t]}' overlap without one being a superset of the other`)}}}}const MinSharedActions=5;class FinishStateContext{constructor(e,t,s,n,r,i,o){this.tokenizers=e,this.data=t,this.stateArray=s,this.skipData=n,this.skipInfo=r,this.states=i,this.builder=o,this.sharedActions=[]}findSharedActions(e){if(e.actions.length<5)return null;let t=null;for(let s of this.sharedActions)(!t||s.actions.length>t.actions.length)&&s.actions.every((t=>e.actions.some((e=>e.eq(t)))))&&(t=s);if(t)return t;let s=null,n=[];for(let t=e.id+1;t<this.states.length;t++){let r=this.states[t],i=0;if(!(r.defaultReduce||r.actions.length<5)){for(let t of e.actions)for(let e of r.actions)t.eq(e)&&(n[i++]=t);i>=5&&(!s||s.length<i)&&(s=n,n=[])}}if(!s)return null;let r={actions:s,addr:this.storeActions(s,-1,null)};return this.sharedActions.push(r),r}storeActions(e,t,s){if(t<0&&s&&s.actions.length==e.length)return s.addr;let n=[];for(let r of e)if(!s||!s.actions.some((e=>e.eq(r))))if(r instanceof Shift)n.push(r.term.id,r.target.id,0);else{let e=reduceAction(r.rule,this.skipInfo);e!=t&&n.push(r.term.id,65535&e,e>>16)}return n.push(65535),t>-1?n.push(2,65535&t,t>>16):s?n.push(1,65535&s.addr,s.addr>>16):n.push(0),this.data.storeArray(n)}finish(e,t,s){let n=this.builder,r=n.skipRules.indexOf(e.skip),i=this.skipData[r],o=this.skipInfo[r].startTokens,a=e.defaultReduce?reduceAction(e.defaultReduce,this.skipInfo):0,l=t?1:0,u=-1,h=null;if(0==a){if(t)for(const t of e.actions)t instanceof Reduce&&t.term.eof&&(u=reduceAction(t.rule,this.skipInfo));u<0&&(h=this.findSharedActions(e))}e.set.some((e=>e.rule.name.top&&e.pos==e.rule.parts.length))&&(l|=2);let p=[];for(let t=0;t<e.actions.length+o.length;t++){let s=t<e.actions.length?e.actions[t].term:o[t-e.actions.length];for(;;){let e=n.tokenOrigins[s.name];if(!e||!e.spec){e&&e.external instanceof ExternalTokenSet&&addToSet(p,e.external);break}s=e.spec}}let c=0;for(let t=0;t<this.tokenizers.length;t++){let s=this.tokenizers[t];(p.includes(s)||s.groupID==e.tokenGroup)&&(c|=1<<t)}let f=6*e.id;this.stateArray[f+0]=l,this.stateArray[f+1]=this.storeActions(a?none:e.actions,u,h),this.stateArray[f+2]=i,this.stateArray[f+3]=c,this.stateArray[f+4]=a,this.stateArray[f+5]=s}}function addToProp(e,t,s){let n=e.props[t];(!n||n.split(" ").indexOf(s)<0)&&(e.props[t]=n?n+" "+s:s)}function buildSpecializeTable(e){let t=Object.create(null);for(let{value:s,term:n,type:r}of e){let e="specialize"==r?0:1;t[s]=n.id<<1|e}return t}function reduceAction(e,t,s=e.parts.length){return 65536|e.name.id|(e.isRepeatWrap&&s==e.parts.length?131072:0)|(t.some((t=>t.rule==e.name))?262144:0)|s<<19}function findArray(e,t){e:for(let s=0;;){let n=e.indexOf(t[0],s);if(-1==n||n+t.length>e.length)break;for(let r=1;r<t.length;r++)if(t[r]!=e[n+r]){s=n+1;continue e}return n}return-1}function findSkipStates(e,t){let s=Object.create(null),n=[],r=e=>{s[e.id]||(s[e.id]=!0,n.push(e))};for(let s of e)s.startRule&&t.includes(s.startRule)&&r(s);for(let e=0;e<n.length;e++){for(let t of n[e].actions)t instanceof Shift&&r(t.target);for(let t of n[e].goto)r(t.target)}return e=>!s[e]}class DataBuilder{constructor(){this.data=[]}storeArray(e){let t=findArray(this.data,e);if(t>-1)return t;let s=this.data.length;for(let t of e)this.data.push(t);return s}finish(){return Uint16Array.from(this.data)}}function computeGotoTable(e){let t={},s=0;for(let n of e)for(let e of n.goto){s=Math.max(e.term.id,s);let r=t[e.term.id]||(t[e.term.id]={});(r[e.target.id]||(r[e.target.id]=[])).push(n.id)}let n=new DataBuilder,r=[],i=s+2;for(let e=0;e<=s;e++){let s=t[e];if(!s){r.push(1);continue}let o=[],a=Object.keys(s);for(let e of a){let t=s[e];o.push((e==a[a.length-1]?1:0)+(t.length<<1)),o.push(+e);for(let e of t)o.push(e)}r.push(n.storeArray(o)+i)}if(r.some((e=>e>65535)))throw new GenError("Goto table too large");return Uint16Array.from([s+1,...r,...n.data])}class TokenGroup{constructor(e,t){this.tokens=e,this.groupID=t}create(){return this.groupID}createSource(){return String(this.groupID)}}function addToSet(e,t){e.includes(t)||e.push(t)}function buildTokenMasks(e){let t=Object.create(null);for(let s of e){let e=1<<s.groupID;for(let n of s.tokens)t[n.id]=(t[n.id]||0)|e}return t}class TokenArg{constructor(e,t,s){this.name=e,this.expr=t,this.scope=s}}class BuildingRule{constructor(e,t,s,n){this.name=e,this.start=t,this.to=s,this.args=n}}class TokenSet{constructor(e,t){this.b=e,this.ast=t,this.startState=new State$1,this.built=[],this.building=[],this.byDialect=Object.create(null),this.precedenceRelations=[],this.rules=t?t.rules:none;for(let t of this.rules)e.unique(t.id)}getToken(e){for(let t of this.built)if(t.matches(e))return t.term;let t=e.id.name,s=this.rules.find((e=>e.id.name==t));if(!s)return null;let{name:n,props:r,dialect:i,exported:o}=this.b.nodeInfo(s.props,"d",t,e.args,s.params.length!=e.args.length?none:s.params),a=this.b.makeTerminal(e.toString(),n,r);return null!=i&&(this.byDialect[i]||(this.byDialect[i]=[])).push(a),(a.nodeType||o)&&0==s.params.length&&(a.nodeType||(a.preserve=!0),this.b.namedTerms[o||t]=a),this.buildRule(s,e,this.startState,new State$1([a])),this.built.push(new BuiltRule(t,e.args,a)),a}buildRule(e,t,s,n,r=none){let i=t.id.name;e.params.length!=t.args.length&&this.b.raise(`Incorrect number of arguments for token '${i}'`,t.start);let o=this.building.find((e=>e.name==i&&exprsEq(t.args,e.args)));if(o){if(o.to==n)return void s.nullEdge(o.start);let e=this.building.length-1;for(;this.building[e].name!=i;)e--;this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(e).map((e=>e.name)).join(" -> ")}`,t.start)}this.b.used(e.id.name);let a=new State$1;s.nullEdge(a),this.building.push(new BuildingRule(i,a,n,t.args)),this.build(this.b.substituteArgs(e.expr,t.args,e.params),a,n,t.args.map(((t,s)=>new TokenArg(e.params[s].name,t,r)))),this.building.pop()}build(e,t,s,n){if(e instanceof NameExpression){let r,i=e.id.name,o=n.find((e=>e.name==i));if(o)return this.build(o.expr,t,s,o.scope);for(let e=0,t=this.b.localTokens;e<=t.length;e++){if(r=(e==t.length?this.b.tokens:t[e]).rules.find((e=>e.id.name==i)),r)break}if(!r)return this.b.raise(`Reference to token rule '${i}', which isn't found`,e.start);this.buildRule(r,e,t,s,n)}else if(e instanceof CharClass)for(let[n,r]of CharClasses[e.type])t.edge(n,r,s);else if(e instanceof ChoiceExpression)for(let r of e.exprs)this.build(r,t,s,n);else if(isEmpty(e))t.nullEdge(s);else if(e instanceof SequenceExpression){let r=e.markers.find((e=>e.length>0));r&&this.b.raise("Conflict marker in token expression",r[0].start);for(let r=0;r<e.exprs.length;r++){let i=r==e.exprs.length-1?s:new State$1;this.build(e.exprs[r],t,i,n),t=i}}else if(e instanceof RepeatExpression)if("*"==e.kind){let r=new State$1;t.nullEdge(r),this.build(e.expr,r,r,n),r.nullEdge(s)}else if("+"==e.kind){let r=new State$1;this.build(e.expr,t,r,n),this.build(e.expr,r,r,n),r.nullEdge(s)}else t.nullEdge(s),this.build(e.expr,t,s,n);else if(e instanceof SetExpression)for(let[n,r]of e.inverted?invertRanges(e.ranges):e.ranges)rangeEdges(t,s,n,r);else if(e instanceof LiteralExpression)for(let n=0;n<e.value.length;n++){let r=e.value.charCodeAt(n),i=n==e.value.length-1?s:new State$1;t.edge(r,r+1,i),t=i}else{if(!(e instanceof AnyExpression))return this.b.raise("Unrecognized expression type in token",e.start);{let e=new State$1;t.edge(0,56320,s),t.edge(56320,65536,s),t.edge(55296,56320,e),e.edge(56320,57344,s)}}}takePrecedences(){let e=this.precedenceRelations=[];if(this.ast)for(let t of this.ast.precedences){let s=[];for(let n of t.items){let t=[];if(n instanceof NameExpression)for(let e of this.built)(n.args.length?e.matches(n):e.id==n.id.name)&&t.push(e.term);else{let e=JSON.stringify(n.value),s=this.built.find((t=>t.id==e));s&&t.push(s.term)}t.length||this.b.warn(`Precedence specified for unknown token ${n}`,n.start);for(let n of t)addRel(e,n,s);s=s.concat(t)}}}precededBy(e,t){let s=this.precedenceRelations.find((t=>t.term==e));return s&&s.after.includes(t)}buildPrecTable(e){let t=[],s=this.precedenceRelations.slice();for(let{a:t,b:n,soft:r}of e)if(r){if(!s.some((e=>e.term==t))||!s.some((e=>e.term==n)))continue;r<0&&([t,n]=[n,t]),addRel(s,n,[t]),addRel(s,t,[])}e:for(;s.length;){for(let e=0;e<s.length;e++){let n=s[e];if(n.after.every((e=>t.includes(e.id)))){if(t.push(n.term.id),1==s.length)break e;s[e]=s.pop();continue e}}this.b.raise(`Cyclic token precedence relation between ${s.map((e=>e.term)).join(", ")}`)}return t}}class MainTokenSet extends TokenSet{constructor(){super(...arguments),this.explicitConflicts=[]}getLiteral(e){let t=JSON.stringify(e.value);for(let e of this.built)if(e.id==t)return e.term;let s=null,n={},r=null,i=null,o=this.ast?this.ast.literals.find((t=>t.literal==e.value)):null;o&&({name:s,props:n,dialect:r,exported:i}=this.b.nodeInfo(o.props,"da",e.value));let a=this.b.makeTerminal(t,s,n);return null!=r&&(this.byDialect[r]||(this.byDialect[r]=[])).push(a),i&&(this.b.namedTerms[i]=a),this.build(e,this.startState,new State$1([a]),none),this.built.push(new BuiltRule(t,none,a)),a}takeConflicts(){var e;let t=e=>{if(e instanceof NameExpression){for(let t of this.built)if(t.matches(e))return t.term}else{let t=JSON.stringify(e.value),s=this.built.find((e=>e.id==t));if(s)return s.term}return this.b.warn(`Precedence specified for unknown token ${e}`,e.start),null};for(let s of(null===(e=this.ast)||void 0===e?void 0:e.conflicts)||[]){let e=t(s.a),n=t(s.b);e&&n&&(e.id<n.id&&([e,n]=[n,e]),this.explicitConflicts.push({a:e,b:n}))}}buildTokenGroups(e,t,s){let n=this.startState.compile();n.accepting.length&&this.b.raise(`Grammar contains zero-length tokens (in '${n.accepting[0].name}')`,this.rules.find((e=>e.id.name==n.accepting[0].name)).start),/\btokens\b/.test(verbose)&&console.log(n.toString());let r=n.findConflicts(checkTogether(e,this.b,t)).filter((({a:e,b:t})=>!this.precededBy(e,t)&&!this.precededBy(t,e)));for(let{a:e,b:t}of this.explicitConflicts)r.some((s=>s.a==e&&s.b==t))||r.push(new Conflict$1(e,t,0,"",""));let i=r.filter((e=>e.soft)),o=r.filter((e=>!e.soft)),a=[],l=[];for(let n of e){if(n.defaultReduce||n.tokenGroup>-1)continue;let e=[],r=[],i=t[this.b.skipRules.indexOf(n.skip)].startTokens;for(let e of i)n.actions.some((t=>t.term==e))&&this.b.raise(`Use of token ${e.name} conflicts with skip rule`);let u=[];for(let e=0;e<n.actions.length+(i?i.length:0);e++){let t=e<n.actions.length?n.actions[e].term:i[e-n.actions.length],s=this.b.tokenOrigins[t.name];if(s&&s.spec)t=s.spec;else if(s&&s.external)continue;addToSet(u,t)}if(0==u.length)continue;for(let t of u)for(let s of o){let i=s.a==t?s.b:s.b==t?s.a:null;if(i){if(u.includes(i)&&!a.some((e=>e.conflict==s))){let e=s.exampleA?` (example: ${JSON.stringify(s.exampleA)}${s.exampleB?` vs ${JSON.stringify(s.exampleB)}`:""})`:"";a.push({error:`Overlapping tokens ${t.name} and ${i.name} used in same context${e}\nAfter: ${n.set[0].trail()}`,conflict:s})}addToSet(e,t),addToSet(r,i)}}let h=null;for(let t of l)if(!r.some((e=>t.tokens.includes(e)))){for(let s of e)addToSet(t.tokens,s);h=t;break}h||(h=new TokenGroup(e,l.length+s),l.push(h)),n.tokenGroup=h.groupID}a.length&&this.b.raise(a.map((e=>e.error)).join("\n\n")),l.length+s>16&&this.b.raise(`Too many different token groups (${l.length}) to represent them as a 16-bit bitfield`);let u=this.buildPrecTable(i);return{tokenGroups:l,tokenPrec:u,tokenData:n.toArray(buildTokenMasks(l),u)}}}class LocalTokenSet extends TokenSet{constructor(e,t){super(e,t),this.fallback=null,t.fallback&&e.unique(t.fallback.id)}getToken(e){let t=null;if(this.ast.fallback&&this.ast.fallback.id.name==e.id.name){if(e.args.length&&this.b.raise(`Incorrect number of arguments for ${e.id.name}`,e.start),!this.fallback){let{name:t,props:s,exported:n}=this.b.nodeInfo(this.ast.fallback.props,"",e.id.name,none,none),r=this.fallback=this.b.makeTerminal(e.id.name,t,s);(r.nodeType||n)&&(r.nodeType||(r.preserve=!0),this.b.namedTerms[n||e.id.name]=r),this.b.used(e.id.name)}t=this.fallback}else t=super.getToken(e);return t&&!this.b.tokenOrigins[t.name]&&(this.b.tokenOrigins[t.name]={group:this}),t}buildLocalGroup(e,t,s){let n=this.startState.compile();n.accepting.length&&this.b.raise(`Grammar contains zero-length tokens (in '${n.accepting[0].name}')`,this.rules.find((e=>e.id.name==n.accepting[0].name)).start);for(let{a:e,b:t,exampleA:s}of n.findConflicts((()=>!0)))this.precededBy(e,t)||this.precededBy(t,e)||this.b.raise(`Overlapping tokens ${e.name} and ${t.name} in local token group${s?` (example: ${JSON.stringify(s)})`:""}`);for(let n of e){if(n.defaultReduce)continue;let e=null,r=t[this.b.skipRules.indexOf(n.skip)].startTokens[0];for(let{term:t}of n.actions){let s=this.b.tokenOrigins[t.name];(null==s?void 0:s.group)==this?e=t:r=t}e&&(r&&this.b.raise(`Tokens from a local token group used together with other tokens (${e.name} with ${r.name})`),n.tokenGroup=s)}let r=this.buildPrecTable(none),i=n.toArray({[s]:65535},r),o=i.length,a=new Uint16Array(i.length+r.length+1);return a.set(i,0),a.set(r,o),a[a.length-1]=65535,{groupID:s,create:()=>new LocalTokenGroup(a,o,this.fallback?this.fallback.id:void 0),createSource:e=>`new ${e("LocalTokenGroup","@lezer/lr")}(${encodeArray(a)}, ${o}${this.fallback?`, ${this.fallback.id}`:""})`}}}function checkTogether(e,t,s){let n=Object.create(null);function r(e,n){return e.actions.some((e=>e.term==n))||s[t.skipRules.indexOf(e.skip)].startTokens.includes(n)}return(t,s)=>{t.id<s.id&&([t,s]=[s,t]);let i=t.id|s.id<<16,o=n[i];return null!=o?o:n[i]=e.some((e=>r(e,t)&&r(e,s)))}}function invertRanges(e){let t=0,s=[];for(let[n,r]of e)n>t&&s.push([t,n]),t=r;return t<=MAX_CODE&&s.push([t,MAX_CODE+1]),s}const ASTRAL=65536,GAP_START=55296,GAP_END=57344,MAX_CODE=1114111,LOW_SURR_B=56320,HIGH_SURR_B=57343;function rangeEdges(e,t,s,n){if(s<ASTRAL&&(s<GAP_START&&e.edge(s,Math.min(n,GAP_START),t),n>GAP_END&&e.edge(Math.max(s,GAP_END),Math.min(n,65536),t),s=ASTRAL),n<=ASTRAL)return;let r=String.fromCodePoint(s),i=String.fromCodePoint(n-1),o=r.charCodeAt(0),a=r.charCodeAt(1),l=i.charCodeAt(0),u=i.charCodeAt(1);if(o==l){let s=new State$1;e.edge(o,o+1,s),s.edge(a,u+1,t)}else{let s=o,n=l;if(a>LOW_SURR_B){s++;let n=new State$1;e.edge(o,o+1,n),n.edge(a,HIGH_SURR_B+1,t)}if(u<HIGH_SURR_B){n--;let s=new State$1;e.edge(l,l+1,s),s.edge(LOW_SURR_B,u+1,t)}if(s<=n){let r=new State$1;e.edge(s,n+1,r),r.edge(LOW_SURR_B,HIGH_SURR_B+1,t)}}}function isEmpty(e){return e instanceof SequenceExpression&&0==e.exprs.length}function gatherExtTokens(e,t){let s=Object.create(null);for(let n of t){e.unique(n.id);let{name:t,props:r,dialect:i}=e.nodeInfo(n.props,"d",n.id.name),o=e.makeTerminal(n.id.name,t,r);null!=i&&(e.tokens.byDialect[i]||(e.tokens.byDialect[i]=[])).push(o),e.namedTerms[n.id.name]=s[n.id.name]=o}return s}function findExtToken(e,t,s){let n=t[s.id.name];return n?(s.args.length&&e.raise("External tokens cannot take arguments",s.args[0].start),e.used(s.id.name),n):null}function addRel(e,t,s){let n=e.findIndex((e=>e.term==t));n<0?e.push({term:t,after:s}):e[n]={term:t,after:e[n].after.concat(s)}}class ExternalTokenSet{constructor(e,t){this.b=e,this.ast=t,this.tokens=gatherExtTokens(e,t.tokens);for(let e in this.tokens)this.b.tokenOrigins[this.tokens[e].name]={external:this}}getToken(e){return findExtToken(this.b,this.tokens,e)}create(){return this.b.options.externalTokenizer(this.ast.id.name,this.b.termTable)}createSource(e){let{source:t,id:{name:s}}=this.ast;return e(s,t)}}class ExternalSpecializer{constructor(e,t){this.b=e,this.ast=t,this.term=null,this.tokens=gatherExtTokens(e,t.tokens)}finish(){let e=this.b.normalizeExpr(this.ast.token);1==e.length&&1==e[0].terms.length&&e[0].terms[0].terminal||this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`,this.ast.token.start),this.term=e[0].terms[0];for(let e in this.tokens)this.b.tokenOrigins[this.tokens[e].name]={spec:this.term,external:this}}getToken(e){return findExtToken(this.b,this.tokens,e)}}function inlineRules(e,t){for(let n=0;;n++){let r,i=Object.create(null);if(0==n)for(let a of e)if(a.name.inline&&!i[a.name.name]){let l=e.filter((e=>e.name==a.name));if(l.some((e=>e.parts.includes(a.name))))continue;r=i[a.name.name]=l}for(let u=0;u<e.length;u++){let h=e[u];h.name.interesting||h.parts.includes(h.name)||!(h.parts.length<3)||t.includes(h.name)||1!=h.parts.length&&!e.every((e=>e.skip==h.skip||!e.parts.includes(h.name)))||h.parts.some((e=>!!i[e.name]))||e.some(((e,t)=>t!=u&&e.name==h.name))||(r=i[h.name.name]=[h])}if(!r)return e;let o=[];for(let p of e){function s(e,t,n){if(e==p.parts.length)return void o.push(new Rule(p.name,n,t,p.skip));let r=p.parts[e],a=i[r.name];if(a)for(let r of a)s(e+1,t.slice(0,t.length-1).concat(t[e].join(r.conflicts[0])).concat(r.conflicts.slice(1,r.conflicts.length-1)).concat(p.conflicts[e+1].join(r.conflicts[r.conflicts.length-1])),n.concat(r.parts));else s(e+1,t.concat(p.conflicts[e+1]),n.concat(r))}i[p.name.name]||(p.parts.some((e=>!!i[e.name]))?s(0,[p.conflicts[0]],[]):o.push(p))}e=o}}function mergeRules(e){let t,s=Object.create(null);for(let n=0;n<e.length;){let r=n,i=e[n++].name;for(;n<e.length&&e[n].name==i;)n++;let o=n-r;if(!i.interesting)for(let a=n;a<e.length;){let n=a,l=e[a++].name;for(;a<e.length&&e[a].name==l;)a++;if(a-n!=o||l.interesting)continue;let u=!0;for(let t=0;t<o&&u;t++){let s=e[r+t],i=e[n+t];0!=s.cmpNoName(i)&&(u=!1)}u&&(t=s[i.name]=l)}}if(!t)return e;let n=[];for(let t of e)s[t.name.name]||n.push(t.parts.every((e=>!s[e.name]))?t:new Rule(t.name,t.parts.map((e=>s[e.name]||e)),t.conflicts,t.skip));return n}function simplifyRules(e,t){return mergeRules(inlineRules(e,t))}function buildParser(e,t={}){let s=new Builder(e,t),n=s.getParser();return n.termTable=s.termTable,n}const KEYWORDS=["await","break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","while","with","null","true","false","instanceof","typeof","void","delete","new","in","this","const","class","extends","export","import","super","enum","implements","interface","let","package","private","protected","public","static","yield","require"];function buildParserFile(e,t={}){return new Builder(e,t).getParserFile()}function ignored(e){let t=e[0];return"_"==t||t.toUpperCase()!=t}function isExported(e){return e.props.some((e=>e.at&&"export"==e.name))}export{GenError,buildParser,buildParserFile};